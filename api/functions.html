<!-- $Id$ -->
<!-- $Source$ -->

<html>
<head>
<title>ProFTPD Developer's Guide: API Functions</title>
</head>

<body bgcolor=white>

<hr><br>
<center>
<img src="../images/proftpd.png" border=0>
<br><br>
<h3><b>ProFTPD Developer's Guide: API Functions</b></h3>
<i><b>ProFTPD Version 1.2</b></i><br>
</center>

<hr>
<a name="__walk_pools"><b>__walk_pools</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static long __walk_pools(pool *<i>p</i>, int <i>level</i>)
</pre>
<font color=blue>Comments</font>: Walk all the pools, start with the top-level
permanent pool, displaying a tree.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/pool.c.html#__walk_pools">src/pool.c</a><br>

<hr>
<a name="_add_allow_deny"><b>_add_allow_deny</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET _add_allow_deny(cmd_rec *<i>cmd</i>, char *<i>name</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#_add_allow_deny">modules/mod_core.c</a><br>

<hr>
<a name="_add_allow_deny_group"><b>_add_allow_deny_group</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET _add_allow_deny_group(cmd_rec *<i>cmd</i>, char *<i>name</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#_add_allow_deny_group">modules/mod_core.c</a><br>

<hr>
<a name="_add_allow_deny_user"><b>_add_allow_deny_user</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET _add_allow_deny_user(cmd_rec *<i>cmd</i>, char *<i>name</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#_add_allow_deny_user">modules/mod_core.c</a><br>

<hr>
<a name="_auth_anonymous_group"><b>_auth_anonymous_group</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static config_rec *_auth_anonymous_group(pool *<i>p</i>, char *<i>user</i>)
</pre>
<font color=blue>Comments</font>: Check to see if the given <i>user</i> is a
member of an <code>AnonymousGroup</code> group, and returns the
<code>config_rec</code> in which the matching <code>AnonymousGroup</code>
directive was found, or else <code>NULL</code>.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_auth.c.html#_auth_anonymous_group">modules/mod_auth.c</a><br>

<hr>
<a name="_auth_group"><b>_auth_group</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static config_rec *_auth_group(pool *<i>p</i>, char *<i>user</i>, char **<i>group</i>, char **<i>ournamep</i>,
    char **<i>anonnamep</i>, char *<i>pass</i>)
</pre>
<font color=blue>Comments</font>: This function handles groups-based
authentication (rarely used), and is only checked if user-based password
authentication fails.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_auth.c.html#_auth_group">modules/mod_auth.c</a><br>

<hr>
<a name="_auth_lookup_id"><b>_auth_lookup_id</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static idmap_t *_auth_lookup_id(xaset_t **<i>id_table</i>, idauth_t <i>id</i>)
</pre>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_unixpw.c.html#_auth_lookup_id">modules/mod_unixpw.c</a><br>

<hr>
<a name="_auth_resolve_user"><b>_auth_resolve_user</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static config_rec *_auth_resolve_user(pool *<i>p</i>, char **<i>user</i>, char **<i>ournamep</i>,
    char **<i>anonnamep</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_auth.c.html#_auth_resolve_user">modules/mod_auth.c</a><br>

<hr>
<a name="_calc_fs"><b>_calc_fs</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  unsigned long _calc_fs(unsigned long <i>blocks</i>, unsigned long <i>bsize</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/support.c.html#_calc_fs">src/support.c</a><br>

<hr>
<a name="_chdir"><b>_chdir</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET _chdir(cmd_rec *<i>cmd</i>, char *<i>ndir</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#_chdir">modules/mod_core.c</a><br>

<hr>
<a name="_check_group_access"><b>_check_group_access</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int _check_group_access(xaset_t *<i>conf</i>, char *<i>name</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#_check_group_access">src/dirtree.c</a><br>

<hr>
<a name="_check_ip_access"><b>_check_ip_access</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int _check_ip_access(xaset_t *<i>conf</i>, char *<i>name</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#_check_ip_access">src/dirtree.c</a><br>

<hr>
<a name="_check_ip_negative"><b>_check_ip_negative</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int _check_ip_negative(const config_rec *<i>c</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#_check_ip_negative">src/dirtree.c</a><br>

<hr>
<a name="_check_ip_positive"><b>_check_ip_positive</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int _check_ip_positive(const config_rec *<i>c</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#_check_ip_positive">src/dirtree.c</a><br>

<hr>
<a name="_check_limit"><b>_check_limit</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int _check_limit(config_rec *<i>c</i>)
</pre>
<font color=blue>Comments</font>:  Checks <code>&lt;Limit&gt;</code> ACLs.
Returns <code>1</code> if the operation is explicitly allowed, <code>0</code>
if implicitly allowed, <code>-1</code> if implicitly denied, and <code>-2</code>
if explicitly denied.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#_check_limit">src/dirtree.c</a><br>

<hr>
<a name="_check_limits"><b>_check_limits</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int _check_limits(xaset_t *<i>set</i>, char *<i>cmd</i>, int <i>hidden</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#_check_limits">src/dirtree.c</a><br>

<hr>
<a name="_check_limit_allow"><b>_check_limit_allow</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int _check_limit_allow(config_rec *<i>c</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#_check_limit_allow">src/dirtree.c</a><br>

<hr>
<a name="_check_limit_deny"><b>_check_limit_deny</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int _check_limit_deny(config_rec *<i>c</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#_check_limit_deny">src/dirtree.c</a><br>

<hr>
<a name="_check_user_access"><b>_check_user_access</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int _check_user_access(xaset_t *<i>conf</i>, char *<i>name</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#_check_user_access">src/dirtree.c</a><br>

<hr>
<a name="_compare_file_mtime"><b>_compare_file_mtime</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int _compare_file_mtime(const struct sort_filename *<i>f1</i>, const struct sort_filename *<i>f2</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_ls.c.html#_compare_file_mtime">modules/mod_ls.c</a><br>

<hr>
<a name="_compare_file_mtime_reversed"><b>_compare_file_mtime_reversed</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int _compare_file_mtime_reversed(const struct sort_filename *<i>f1</i>, const struct sort_filename *<i>f2</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_ls.c.html#_compare_file_mtime_reversed">modules/mod_ls.c</a><br>

<hr>
<a name="_compare_gid"><b>_compare_gid</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  inline static int _compare_gid(idmap_t *<i>m1</i>, idmap_t *<i>m2</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_unixpw.c.html#_compare_gid">modules/mod_unixpw.c</a><br>

<hr>
<a name="_compare_id"><b>_compare_id</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  inline static int _compare_id(xaset_t **<i>table</i>, idauth_t <i>id</i>, idauth_t <i>idcomp</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_unixpw.c.html#_compare_id">modules/mod_unixpw.c</a><br>

<hr>
<a name="_compare_sym"><b>_compare_sym</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int _compare_sym(struct symbol_hash *<i>s1</i>, struct symbol_hash *<i>s2</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/modules.c.html#_compare_sym">src/modules.c</a><br>

<hr>
<a name="_compare_uid"><b>_compare_uid</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  inline static int _compare_uid(idmap_t *<i>m1</i>, idmap_t *<i>m2</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_unixpw.c.html#_compare_uid">modules/mod_unixpw.c</a><br>

<hr>
<a name="_copy_global_to_all"><b>_copy_global_to_all</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void _copy_global_to_all(xaset_t *<i>set</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#_copy_global_to_all">src/dirtree.c</a><br>

<hr>
<a name="_copy_recur"><b>_copy_recur</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void _copy_recur(xaset_t **<i>set</i>, pool *<i>p</i>, config_rec *<i>c</i>, config_rec *<i>new_parent</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#_copy_recur">src/dirtree.c</a><br>

<hr>
<a name="_create_inet_pool"><b>_create_inet_pool</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static void _create_inet_pool(void)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/inet.c.html#_create_inet_pool">src/inet.c</a><br>

<hr>
<a name="_data_active_open"><b>_data_active_open</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int _data_active_open(char *<i>reason</i>, unsigned long <i>size</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/data.c.html#_data_active_open">src/data.c</a><br>

<hr>
<a name="_data_new_xfer"><b>_data_new_xfer</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static void _data_new_xfer(char *<i>filename</i>, int <i>direction</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/data.c.html#_data_new_xfer">src/data.c</a><br>

<hr>
<a name="_data_pasv_open"><b>_data_pasv_open</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int _data_pasv_open(char *<i>reason</i>, unsigned long <i>size</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/data.c.html#_data_pasv_open">src/data.c</a><br>

<hr>
<a name="_dir_check_op"><b>_dir_check_op</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int _dir_check_op(pool *<i>p</i>, xaset_t *<i>c</i>, int <i>op</i>, int <i>uid</i>, int <i>gid</i>, int <i>mode</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#_dir_check_op">src/dirtree.c</a><br>

<hr>
<a name="_dispatch"><b>_dispatch</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
 static int _dispatch(cmd_rec *<i>cmd</i>, int <i>cmd_type</i>, int <i>validate</i>, char *<i>match</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/main.c.html#_dispatch">src/main.c</a><br>

<hr>
<a name="_dispatch_auth"><b>_dispatch_auth</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static modret_t *_dispatch_auth(cmd_rec *<i>cmd</i>, char *<i>match</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/auth.c.html#_dispatch_auth">src/auth.c</a><br>

<hr>
<a name="_do_auth"><b>_do_auth</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int _do_auth(pool *<i>p</i>, xaset_t *<i>conf</i>, char *<i>u</i>, char *<i>pw</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_auth.c.html#_do_auth">modules/mod_auth.c</a><br>

<hr>
<a name="_dup_low_fd"><b>_dup_low_fd</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int _dup_low_fd(int <i>fd</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/main.c.html#_dup_low_fd">src/main.c</a><br>

<hr>
<a name="_exists"><b>_exists</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int _exists(char *<i>path</i>, int <i>dirp</i>)
</pre>
<font color=blue>Comments</font>:  This function simply checks for the
existence of the given <i>path</i>, as modified by the <i>dirp</i> argument.<br>
<br>
If <code>dirp == 1</code>, returns <code>FALSE</code> unless <i>path</i> is
an existing directory.  If <code>dirp == 0</code>, returns <code>FALSE</code>
unless <i>path</i> is an existing <b>non</b>-directory.  If
<code>dirp == -1</code>, returns <code>FALSE</code> unless <i>path</i> exists;
the caller in this case does not care whether <i>path</i> is a file or
a directory.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/support.c.html#_exists">src/support.c</a><br>

<hr>
<a name="_find_best_dir"><b>_find_best_dir</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static config_rec *_find_best_dir(xaset_t *<i>set</i>, char *<i>path</i>, int *<i>matchlen</i>)
</pre>
<font color=blue>Comments</font>:  Recursively find the most appropriate
place to which to move a
<a href="macros.html#CONF_DIR"><code>CONF_DIR</code></a> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#_find_best_dir">src/dirtree.c</a><br>

<hr>
<a name="_find_ls_limit"><b>_find_ls_limit</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static config_rec *_find_ls_limit(char *<i>ftp_cmd</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_ls.c.html#_find_ls_limit">modules/mod_ls.c</a><br>

<hr>
<a name="_get_default_chdir"><b>_get_default_chdir</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static char *_get_default_chdir(pool *<i>p</i>, xaset_t *<i>conf</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_auth.c.html#_get_default_chdir">modules/mod_auth.c</a><br>

<hr>
<a name="_get_default_root"><b>_get_default_root</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static char *_get_default_root(pool *<i>p</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_auth.c.html#_get_default_root">modules/mod_auth.c</a><br>

<hr>
<a name="_get_full_cmd"><b>_get_full_cmd</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static char *_get_full_cmd(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_site.c.html#_get_full_cmd">modules/mod_site.c</a><br>

<hr>
<a name="_get_gmtoff"><b>_get_gmtoff</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  struct tm *_get_gmtoff(int *<i>tz</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_log.c.html#_get_gmtoff">modules/mod_log.c</a><br>

<hr>
<a name="_get_ppw_info"><b>_get_ppw_info</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static char *_get_ppw_info(pool *<i>p</i>, const char *<i>u</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_unixpw.c.html#_get_ppw_info">modules/mod_unixpw.c</a><br>

<hr>
<a name="_get_pw_info"><b>_get_pw_info</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static char *_get_pw_info(pool *<i>p</i>, const char *<i>u</i>, time_t *<i>lstchg</i>, time_t *<i>min</i>, time_t *<i>max</i>,
    time_t *<i>warn</i>, time_t *<i>inact</i>, time_t *<i>expire</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_unixpw.c.html#_get_pw_info">modules/mod_unixpw.c</a><br>

<hr>
<a name="_hash_find"><b>_hash_find</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static struct symbol_hash *_hash_find(int <i>index</i>, char *<i>name</i>, int <i>type</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/modules.c.html#_hash_find">src/modules.c</a><br>

<hr>
<a name="_hash_find_next"><b>_hash_find_next</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static struct symbol_hash *_hash_find_next(int <i>index</i>, char *<i>name</i>, int <i>type</i>, void *<i>last</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/modules.c.html#_hash_find_next">src/modules.c</a><br>

<hr>
<a name="_hash_index"><b>_hash_index</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int _hash_index(char *<i>name</i>)
</pre>
<font color=blue>Comments</font>: Hash function for generating indices for
the modules' symbol tables.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/modules.c.html#_hash_index">src/modules.c</a><br>

<hr>
<a name="_hash_insert"><b>_hash_insert</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int _hash_insert(struct symbol_hash *<i>sym</i>)
</pre>
<font color=blue>Comments</font>: Inserts the given <i>sym</i> into the
<code>xaset_t</code> symtable array, which is static to modules.c.  The
<code><a href="#_compare_sym">_compare_sym()</a></code> function is used
as the comparison function for the items in the symtable <code>xaset</code>.
This function returns the index at which <i>sym</i> was inserted.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/modules.c.html#_hash_insert">src/modules.c</a><br>

<hr>
<a name="_hash_insert_auth"><b>_hash_insert_auth</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int _hash_insert_auth(authtable *<i>auth</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/modules.c.html#_hash_insert_auth">src/modules.c</a><br>

<hr>
<a name="_hash_insert_cmd"><b>_hash_insert_cmd</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int _hash_insert_cmd(cmdtable *<i>cmd</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/modules.c.html#_hash_insert_cmd">src/modules.c</a><br>

<hr>
<a name="_hash_insert_conf"><b>_hash_insert_conf</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int _hash_insert_conf(conftable *<i>conf</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/modules.c.html#_hash_insert_conf">src/modules.c</a><br>

<hr>
<a name="_internal_abort"><b>_internal_abort</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static void _internal_abort(void)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/main.c.html#_internal_abort">src/main.c</a><br>

<hr>
<a name="_log_transfer"><b>_log_transfer</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static void _log_transfer(char <i>direction</i>, char <i>abort_flag</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_xfer.c.html#_log_transfer">modules/mod_xfer.c</a><br>

<hr>
<a name="_make_cmd"><b>_make_cmd</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static cmd_rec *_make_cmd(pool *<i>cp</i>, int <i>argc</i>, ...)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/auth.c.html#_make_cmd">src/auth.c</a><br>

<hr>
<a name="_mergedown"><b>_mergedown</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
 static void _mergedown(xaset_t *<i>set</i>, int <i>dynamic</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#_mergedown">src/dirtree.c</a><br>

<hr>
<a name="_parse_classes"><b>_parse_classes</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int _parse_classes(char *<i>s</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_log.c.html#_parse_classes">modules/mod_log.c</a><br>

<hr>
<a name="_parse_options"><b>_parse_options</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void _parse_options(char **<i>opt</i>, int *<i>glob_flags</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_ls.c.html#_parse_options">modules/mod_ls.c</a><br>

<hr>
<a name="_prepare_core"><b>_prepare_core</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static char *_prepare_core(void)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/main.c.html#_prepare_core">src/main.c</a><br>

<hr>
<a name="_rate_diffusec"><b>_rate_diffusec</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static float _rate_diffusec(struct timeval <i>tlast</i>, struct timeval <i>t</i>)
</pre>
<font color=blue>Comments</font>: This function calculates the difference,
in microseconds, between <code>timeval</code>'s.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_xfer.c.html#_rate_diffusec">modules/mod_xfer.c</a><br>

<hr>
<a name="_rate_throttle"><b>_rate_throttle</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static void _rate_throttle(unsigned long <i>rate_pos</i>, long <i>rate_bytes</i>, struct timeval <i>rate_tvlast</i>,
    long <i>rate_freebytes</i>, long <i>rate_bps</i>, int <i>rate_hardbps</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_xfer.c.html#_rate_throttle">modules/mod_xfer.c</a><br>

<hr>
<a name="_recur_match_path"><b>_recur_match_path</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static config_rec *_recur_match_path(pool *<i>p</i>, xaset_t *<i>si</i>, char *<i>path</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#_recur_match_path">src/dirtree.c</a><br>

<hr>
<a name="_reorder_dirs"><b>_reorder_dirs</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static void _reorder_dirs(xaset_t *<i>set</i>, int <i>mask</i>)
</pre>
<font color=blue>Comments</font>:  Reorder all the
<a href="macros.html#CONF_DIR"><code>CONF_DIR</code></a> configuration
sections in the given <i>set</i> so that they are in directory tree
order.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#_reorder_dirs">src/dirtree.c</a><br>

<hr>
<a name="_reparent_all"><b>_reparent_all</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static void _reparent_all(config_rec *<i>newparent</i>, xaset_t *<i>set</i>)
</pre>
<font color=blue>Comments</font>: Move all the members (<i>i.e.</i> a
&quot;branch&quot;) of the given configuration <i>set</i> to a different
configuration set, <i>newparent</i>.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#_reparent_all">src/dirtree.c</a><br>

<hr>
<a name="_scan_fsdir"><b>_scan_fsdir</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static fsdir_t *_scan_fsdir(const char *<i>path</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#_scan_fsdir">src/fs.c</a><br>

<hr>
<a name="_scan_fsmatch"><b>_scan_fsmatch</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static fsmatch_t *_scan_fsmatch(const char *<i>path</i>, int <i>op</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#_scan_fsmatch">src/fs.c</a><br>

<hr>
<a name="_set_oobinline"><b>_set_oobinline</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void _set_oobinline(int <i>fd</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/inet.c.html#_set_oobinline">src/inet.c</a><br>

<hr>
<a name="_set_owner"><b>_set_owner</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void _set_owner(int <i>fd</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/inet.c.html#_set_owner">src/inet.c</a><br>

<hr>
<a name="_sethide"><b>_sethide</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET _sethide(cmd_rec *<i>cmd</i>, const char *<i>param</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_ls.c.html#_sethide">modules/mod_ls.c</a><br>

<hr>
<a name="_setup_environment"><b>_setup_environment</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int _setup_environment(pool *<i>p</i>, char *<i>user</i>, char *<i>pass</i>)
</pre>
<font color=blue>Comments</font>: <i>This function <b>really</b> need to be
broken up, rearranged!</i><br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_auth.c.html#_setup_environment">modules/mod_auth.c</a><br>

<hr>
<a name="_stor_chown"><b>_stor_chown</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static void _stor_chown(void)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_xfer.c.html#_stor_chown">modules/mod_xfer.c</a><br>

<hr>
<a name="_strmatch"><b>_strmatch</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int _strmatch(register char *<i>s1</i>, register char *<i>s2</i>)
</pre>
<font color=blue>Comments</font>:  Returns the number of characters which
match, character for character, in the given strings <i>s1</i> and <i>s2</i>.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#_strmatch">src/dirtree.c</a><br>

<hr>
<a name="_symlink"><b>_symlink</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static mode_t _symlink(char *<i>path</i>, ino_t <i>last_inode</i>, int <i>rcount</i>)
</pre>
<font color=blue>Comments</font>:  Returns the <code>mode_t</code>, including
file type, of the file pointed to by the symlink <i>path</i>, or <code>0</code>
if the pointed to file does not exist (<i>i.e. path</i> is a dangling
symlink).  This recursing function catches symlink loops via the
<i>last_inode</i> and <i>rcount</i> arguments.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/support.c.html#_symlink">src/support.c</a><br>

<hr>
<a name="_transmit_data"><b>_transmit_data</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static long _transmit_data(int <i>rate_bps</i>, unsigned long <i>count</i>, off_t <i>offset</i>, char *<i>buf</i>, long <i>bufsize</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_xfer.c.html#_transmit_data">modules/mod_xfer.c</a><br>

<hr>
<a name="_transmit_normal"><b>_transmit_normal</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int _transmit_normal(char *<i>buf</i>, long <i>bufsize</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_xfer.c.html#_transmit_normal">modules/mod_xfer.c</a><br>

<hr>
<a name="_transmit_sendfile"><b>_transmit_sendfile</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int _transmit_sendfile(int <i>rate_bps</i>, unsigned long <i>count</i>, off_t <i>offset</i>, pr_sendfile_t *<i>retval</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_xfer.c.html#_transmit_sendfile">modules/mod_xfer.c</a><br>

<hr>
<a name="_xlate_ascii_read"><b>_xlate_ascii_read</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int _xlate_ascii_read(char *<i>buf</i>, int *<i>bufsize</i>, int *<i>adjlen</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/data.c.html#_xlate_ascii_read">src/data.c</a><br>

<hr>
<a name="_xlate_ascii_write"><b>_xlate_ascii_write</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int _xlate_ascii_write(char **<i>buf</i>, int *<i>bufsize</i>, int *<i>adjlen</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/data.c.html#_xlate_ascii_write">src/data.c</a><br>

<hr>
<a name="accept_binding"><b>accept_binding</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  conn_t *accept_binding(fd_set *<i>rfd</i>, int *<i>lfd</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/main.c.html#accept_binding">src/main.c</a><br>

<hr>
<a name="access_check"><b>access_check</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int access_check(char *<i>path</i>, int <i>mode</i>)
</pre>
<font color=blue>Comments</font>:  This function performs access checks much
like <code>access(2)</code>, except that the process's <b>effective</b>
user ID and group ID are used (<code>access(2)</code> uses the <b>real</b>
user ID and group ID).  As with <code>access(2)</code>, <i>mode</i> is a mask
consisting of one or more of <code>R_OK</code>, <code>W_OK</code>,
<code>X_OK</code> and <code>F_OK</code>.  <code>R_OK</code>, <code>W_OK</code>,
and <code>X_OK</code> request checking whether the <i>path</i> exists and has
read, write, and execute permissions, respectively.  <code>F_OK</code> requests
merely checking for the existence of <i>path</i>.  <code>0</code> is returned
if acccess is granted, <code>-1</code> if denied, with <code>errno</code>
set appropriately.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/support.c.html#access_check">src/support.c</a><br>

<hr>
<a name="add_allow"><b>add_allow</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET add_allow(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>Allow</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#add_allow">modules/mod_core.c</a><br>

<hr>
<a name="add_allowgroup"><b>add_allowgroup</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET add_allowgroup(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>AllowGroup</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#add_allowgroup">modules/mod_core.c</a><br>

<hr>
<a name="add_allowuser"><b>add_allowuser</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET add_allowuser(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>AllowUser</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#add_allowuser">modules/mod_core.c</a><br>

<hr>
<a name="add_anonymous"><b>add_anonymous</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET add_anonymous(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>&lt;Anonymous&gt;</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#add_anonymous">modules/mod_core.c</a><br>

<hr>
<a name="add_anonymousgroup"><b>add_anonymousgroup</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET add_anonymousgroup(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>AnonymousGroup</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#add_anonymousgroup">modules/mod_core.c</a><br>

<hr>
<a name="add_bind"><b>add_bind</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET add_bind(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>Bind</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#add_bind">modules/mod_core.c</a><br>

<hr>
<a name="add_binding"><b>add_binding</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int add_binding(server_rec *<i>server</i>, p_in_addr_t *<i>ipaddr</i>, conn_t *<i>listen</i>, char <i>isdefault</i>,
    char <i>islocalhost</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/main.c.html#add_binding">src/main.c</a><br>

<hr>
<a name="add_cdir"><b>add_cdir</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
 static cdir_t *add_cdir(class_t *<i>class</i>, u_int_32 <i>address</i>, u_int_8 <i>netmask</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#add_cdir">modules/mod_core.c</a><br>

<hr>
<a name="add_cdpath"><b>add_cdpath</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET add_cdpath(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>CDPath</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#add_cdpath">modules/mod_core.c</a><br>

<hr>
<a name="add_class"><b>add_class</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static class_t *add_class(char *<i>name</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#add_class">modules/mod_core.c</a><br>

<hr>
<a name="add_config"><b>add_config</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  config_rec *add_config(const char *<i>name</i>)
</pre>
<font color=blue>Comments</font>:  Adds a <code>config_rec</code> on the
current &quot;level&quot; of the configuration stack.  This is used during
the parsing of configuration files.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#add_config">src/dirtree.c</a><br>

<hr>
<a name="add_config_param"><b>add_config_param</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  config_rec *add_config_param(const char *<i>name</i>, int <i>num</i>, ...)
</pre>
<font color=blue>Comments</font>:  Adds a <code>config_rec</code> to the
server's set with name <i>name</i>.  The added <code>config_rec</code> will
have <i>num</i> arguments, each of which must a <code>void *</code> pointers to
data.  The given number of pointers <i>num</i> must follow.  If planning to
set those additional arguments manually, after this call, at least use
<code>NULL</code> as a placeholder in the argument list.  This function, being
a varargs function, will happily copy garbage from the stack into the created
<code>config_rec</code> if an insufficient number of pointers follow the
<i>num</i> argument.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#add_config_param">src/dirtree.c</a><br>

<hr>
<a name="add_config_param_set"><b>add_config_param_set</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  config_rec *add_config_param_set(xaset_t **<i>set</i>, const char *<i>name</i>, int <i>num</i>, ...)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#add_config_param_set">src/dirtree.c</a><br>

<hr>
<a name="add_config_param_str"><b>add_config_param_str</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  config_rec *add_config_param_str(const char *<i>name</i>, int <i>num</i>, ...)
</pre>
<font color=blue>Comments</font>:  Similar to
<a href="#add_config_param"><code>add_config_param()</code></a>, except that
the given pointers are all assumed to be strings.
<a href="#pstrdup"><code>pstrdup()</code></a> will be called on each pointer,
using <code>permanent_pool</code> as the pool.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#add_config_param_str">src/dirtree.c</a><br>

<hr>
<a name="add_config_set"><b>add_config_set</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  config_rec *add_config_set(xaset_t **<i>set</i>, const char *<i>name</i>)
</pre>
<font color=blue>Comments</font>: Adds a <code>config_rec</code> to the given
<code>xaset_t</code> <i>set</i>, giving that <code>config_rec</code> the
name <i>name</i>.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#add_config_set">src/dirtree.c</a><br>

<hr>
<a name="add_defaultchdir"><b>add_defaultchdir</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET add_defaultchdir(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>DefaultChdir</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_auth.c.html#add_defaultchdir">modules/mod_auth.c</a><br>

<hr>
<a name="add_defaultroot"><b>add_defaultroot</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET add_defaultroot(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>DefaultRoot</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_auth.c.html#add_defaultroot">modules/mod_auth.c</a><br>

<hr>
<a name="add_define"><b>add_define</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET add_define(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>Define</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#add_define">modules/mod_core.c</a><br>

<hr>
<a name="add_deny"><b>add_deny</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET add_deny(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>Deny</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#add_deny">modules/mod_core.c</a><br>

<hr>
<a name="add_denygroup"><b>add_denygroup</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET add_denygroup(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>DenyGroup</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#add_denygroup">modules/mod_core.c</a><br>

<hr>
<a name="add_denyuser"><b>add_denyuser</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET add_denyuser(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>DenyUser</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#add_denyuser">modules/mod_core.c</a><br>

<hr>
<a name="add_directory"><b>add_directory</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET add_directory(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>&lt;Directory&gt;</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#add_directory">modules/mod_core.c</a><br>

<hr>
<a name="add_exit_handler"><b>add_exit_handler</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void add_exit_handler(void (*<i>f</i>)())
</pre>
<font color=blue>Comments</font>:  Register a function <i>f</i> to be run
when the server exits normally, and the
<a href="#run_exit_handlers"><code>run_exit_handlers()</code></a> function is
called, which happens in
<a href="#end_login_noexit"><code>end_login_noexit()</code></a>.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/support.c.html#add_exit_handler">src/support.c</a><br>

<hr>
<a name="add_extendedlog"><b>add_extendedlog</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET add_extendedlog(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>ExtendedLog</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_log.c.html#add_extendedlog">modules/mod_log.c</a><br>

<hr>
<a name="add_global"><b>add_global</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET add_global(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>&lt;Global&gt;</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#add_global">modules/mod_core.c</a><br>

<hr>
<a name="add_groupowner"><b>add_groupowner</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET add_groupowner(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>GroupOwner</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#add_groupowner">modules/mod_core.c</a><br>

<hr>
<a name="add_hidegroup"><b>add_hidegroup</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET add_hidegroup(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>HideGroup</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#add_hidegroup">modules/mod_core.c</a><br>

<hr>
<a name="add_hideuser"><b>add_hideuser</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET add_hideuser(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>HideUser</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#add_hideuser">modules/mod_core.c</a><br>

<hr>
<a name="add_hostname"><b>add_hostname</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static hostname_t *add_hostname(class_t *<i>class</i>, char *<i>name</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#add_hostname">modules/mod_core.c</a><br>

<hr>
<a name="add_include"><b>add_include</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET add_include(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>Include</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#add_include">modules/mod_core.c</a><br>

<hr>
<a name="add_limit"><b>add_limit</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET add_limit(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>&lt;Limit&gt;</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#add_limit">modules/mod_core.c</a><br>

<hr>
<a name="add_logformat"><b>add_logformat</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET add_logformat(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>LogFormat</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_log.c.html#add_logformat">modules/mod_log.c</a><br>

<hr>
<a name="add_masqueradeaddress"><b>add_masqueradeaddress</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET add_masqueradeaddress(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>MasqueradeAddress</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#add_masqueradeaddress">modules/mod_core.c</a><br>

<hr>
<a name="add_meta"><b>add_meta</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static void add_meta(unsigned char **<i>s</i>, unsigned char <i>meta</i>, int <i>args</i>, ...)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_log.c.html#add_meta">modules/mod_log.c</a><br>

<hr>
<a name="add_order"><b>add_order</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET add_order(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>Order</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#add_order">modules/mod_core.c</a><br>

<hr>
<a name="add_ratebool"><b>add_ratebool</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET add_ratebool(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>RateReadHardBPS</code> and <code>RateWriteHardBPS</code> directives.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_xfer.c.html#add_ratebool">modules/mod_xfer.c</a><br>

<hr>
<a name="add_ratenum"><b>add_ratenum</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET add_ratenum(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>RateReadBPS</code>, <code>RateReadFreeBytes</code>,
<code>RateWriteBPS</code>, and <code>RateWriteFreeBytes</code> directives.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_xfer.c.html#add_ratenum">modules/mod_xfer.c</a><br>

<hr>
<a name="add_response"><b>add_response</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void add_response(const char *<i>numeric</i>, const char *<i>fmt</i>, ...)
</pre>
<font color=blue>Comments</font>:  Add the given <i>numeric</i> and
formatted message to the end of the success response chain, to be sent to
the client if the FTP command completes successfully.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/main.c.html#add_response">src/main.c</a><br>

<hr>
<a name="add_response_err"><b>add_response_err</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void add_response_err(const char *<i>numeric</i>, const char *<i>fmt</i>, ...)
</pre>
<font color=blue>Comments</font>:  Add the given <i>numeric</i> and
formatted message to the error response chain, to be sent to the client if
the FTP command processing results in an error.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/main.c.html#add_response_err">src/main.c</a><br>

<hr>
<a name="add_timer"><b>add_timer</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int add_timer(int <i>seconds</i>, int <i>timerno</i>, module *<i>mod</i>, callback_t <i>cb</i>)
</pre>
<font color=blue>Comments</font>:  Create and activate a new timer with an
interval <i>seconds</i>, a timer ID number of <i>timerno</i>, and a callback
of <i>cb</i>.  Note that if a <i>timerno</i> of -1 is given, a
&quot;dynamic&quot; timer ID number will be assigned.  The <i>timerno</i>
of the timer is returned.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/timers.c.html#add_timer">src/timers.c</a><br>

<hr>
<a name="add_transferlog"><b>add_transferlog</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET add_transferlog(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>TransferLog</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#add_transferlog">modules/mod_core.c</a><br>

<hr>
<a name="add_userdirroot"><b>add_userdirroot</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET add_userdirroot (cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>UserDirRoot</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_auth.c.html#add_userdirroot">modules/mod_auth.c</a><br>

<hr>
<a name="add_userowner"><b>add_userowner</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET add_userowner(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>UserOwner</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#add_userowner">modules/mod_core.c</a><br>

<hr>
<a name="add_virtualhost"><b>add_virtualhost</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET add_virtualhost(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>&lt;VirtualHost&gt;</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#add_virtualhost">modules/mod_core.c</a><br>

<hr>
<a name="addfile"><b>addfile</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static void addfile(cmd_rec *<i>cmd</i>, const char *<i>name</i>, const char *<i>suffix</i>, time_t <i>mtime</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_ls.c.html#addfile">modules/mod_ls.c</a><br>

<hr>
<a name="addl_bindings"><b>addl_bindings</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void addl_bindings(server_rec *<i>s</i>)
</pre>
<font color=blue>Comments</font>:  On startup, once the configuration file has
been parsed, this function is called.  It loops through the given server
<i>s</i>'s configuration records, and for each <code>Bind</code> directive
found, it will create an additional
<a href="typedefs.html#binding_t"><code>binding_t</code></a> for that
server's IP address and port.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/main.c.html#addl_bindings">src/main.c</a><br>

<hr>
<a name="allow_dyn_config"><b>allow_dyn_config</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int allow_dyn_config(void)
</pre>
<font color=blue>Comments</font>:<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#allow_dyn_config">src/dirtree.c</a><br>

<hr>
<a name="append_arrays"><b>append_arrays</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  array_header *append_arrays(pool *<i>p</i>, const array_header *<i>first</i>, const array_header *<i>second</i>)
</pre>
<font color=blue>Comments</font>: Using memory from <code>pool</code> <i>p</i>,
copy <code>array_header</code> <i>first</i>, then append
<code>array_header</code> <i>second</i> to it, and return a pointer to the
concatenated <code>array_header</code>s.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/pool.c.html#append_arrays">src/pool.c</a><br>

<hr>
<a name="array_cat"><b>array_cat</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void array_cat(array_header *<i>dst</i>, const array_header *<i>src</i>)
</pre>
<font color=blue>Comments</font>: Concatenate the elements from
<code>array_header</code> <i>src</i> to the elements of
<code>array_header</code> <i>dst</i>.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/pool.c.html#array_cat">src/pool.c</a><br>

<hr>
<a name="auth_acct"><b>auth_acct</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET auth_acct(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Command handler for the <code>ACCT</code>
FTP command.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_auth.c.html#auth_acct">modules/mod_auth.c</a><br>

<hr>
<a name="auth_authenticate"><b>auth_authenticate</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int auth_authenticate(pool *<i>p</i>, const char *<i>name</i>, const char *<i>pw</i>)
</pre>
<font color=blue>Comments</font>: Dispatcher for the
<code>auth()</code> authentication handler.<br>
<br>
The purpose of the dispatched-to authentication handler is to provide a
higher-level &quot;yes or no&quot; answer of whether a the given
user <i>name</i> is successfully authenticated by the given cleartext
password <i>pw</i>.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/auth.c.html#auth_authenticate">src/auth.c</a><br>

<hr>
<a name="auth_check"><b>auth_check</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int auth_check(pool *<i>p</i>, const char *<i>cpw</i>, const char *<i>name</i>, const char *<i>pw</i>)
</pre>
<font color=blue>Comments</font>: Dispatcher for the
<code>check()</code> authentication handler.<br>
<br>
The purpose of the dispatched-to authentication handler is to, given the
hashed password <i>cpw</i>, the username <i>name</i>, and the cleartext password
<i>pw</i>, and using whatever method the module developer desires, determine
whether the hashed password is sufficient and proper for that user, if the
the cleartext password belongs to that user.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/auth.c.html#auth_check">src/auth.c</a><br>

<hr>
<a name="auth_check_ftpusers"><b>auth_check_ftpusers</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static unsigned char auth_check_ftpusers(xaset_t *<i>set</i>, const char *<i>user</i>)
</pre>
<font color=blue>Comments</font>:  Check the given <i>user</i> against a list
of prohibited users, usually contained in <code>/etc/ftpusers</code>, a file
used by <code>wu-ftpd</code> servers.  This check can be skipped by using the
<code>UseFtpUsers</code> configuration directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_auth.c.html#auth_check_ftpusers">modules/mod_auth.c</a><br>

<hr>
<a name="auth_check_shell"><b>_auth_check_shell</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static unsigned char auth_check_shell(xaset_t *<i>set</i>, const char *<i>shell</i>)
</pre>
<font color=blue>Comments</font>: Check the given <i>shell</i> of the
connecting user against a list of valid system shells, usually contained in
<code>/etc/shells</code>.  This check can be skipped by using the
<code>RequireValidShell</code> configuration directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_auth.c.html#auth_check_shell">modules/mod_auth.c</a><br>

<hr>
<a name="auth_cmd_chk_cb"><b>auth_cmd_chk_cb</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int auth_cmd_chk_cb(cmd_rec *cmd)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_auth.c.html#auth_cmd_chk_cb">modules/mod_auth.c</a><br>

<hr>
<a name="auth_count_scoreboard"><b>auth_count_scoreboard</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static void auth_count_scoreboard(cmd_rec *<i>cmd</i>, char *<i>user</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_auth.c.html#auth_count_scoreboard">modules/mod_auth.c</a><br>

<hr>
<a name="auth_endgrent"><b>auth_endgrent</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void auth_endgrent(pool *<i>p</i>)
</pre>
<font color=blue>Comments</font>: Dispatcher for the
<code>endgrent()</code> authentication handler.<br>
<br>
The purpose of the dispatched-to authentication handler is to provide a
custom implementation of the <code>endgrent(3)</code> libc function.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/auth.c.html#auth_endgrent">src/auth.c</a><br>

<hr>
<a name="auth_endpwent"><b>auth_endpwent</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void auth_endpwent(pool *<i>p</i>)
</pre>
<font color=blue>Comments</font>: Dispatcher for the
<code>endpwent()</code> authentication handler.<br>
<br>
The purpose of the dispatched-to authentication handler is to provide a
custom implementation of the <code>endpwent(3)</code> libc function.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/auth.c.html#auth_endpwent">src/auth.c</a><br>

<hr>
<a name="auth_getgrent"><b>auth_getgrent</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  struct group *auth_getgrent(pool *<i>p</i>)
</pre>
<font color=blue>Comments</font>: Dispatcher for the
<code>getgrent()</code> authentication handler.<br>
<br>
The purpose of the dispatched-to authentication handler is to provide a
custom implementation of the <code>getgrent(3)</code> libc function.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/auth.c.html#auth_getgrent">src/auth.c</a><br>

<hr>
<a name="auth_getgrgid"><b>auth_getgrgid</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  struct group *auth_getgrgid(pool *<i>p</i>, gid_t <i>gid</i>)
</pre>
<font color=blue>Comments</font>: Dispatcher for the
<code>getgrgid()</code> authentication handler.<br>
<br>
The purpose of the dispatched-to authentication handler is to provide a
custom implementation of the <code>getgrgid(3)</code> libc function.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/auth.c.html#auth_getgrgid">src/auth.c</a><br>

<hr>
<a name="auth_getgrnam"><b>auth_getgrnam</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  struct group *auth_getgrnam(pool *<i>p</i>, const char *<i>name</i>)
</pre>
<font color=blue>Comments</font>: Dispatcher for the
<code>getgrnam()</code> authentication handler.<br>
<br>
The purpose of the dispatched-to authentication handler is to provide a
custom implementation of the <code>getgrnam(3)</code> libc function.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/auth.c.html#auth_getgrnam">src/auth.c</a><br>

<hr>
<a name="auth_getpwent"><b>auth_getpwent</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  struct passwd *auth_getpwent(pool *<i>p</i>)
</pre>
<font color=blue>Comments</font>: Dispatcher for the
<code>getpwent()</code> authentication handler.<br>
<br>
The purpose of the dispatched-to authentication handler is to provide a
custom implementation of the <code>getpwent(3)</code> libc function.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/auth.c.html#auth_getpwent">src/auth.c</a><br>

<hr>
<a name="auth_getpwnam"><b>auth_getpwnam</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  struct passwd *auth_getpwnam(pool *<i>p</i>, const char *<i>name</i>)
</pre>
<font color=blue>Comments</font>: Dispatcher for the
<code>getpwnam()</code> authentication handler.<br>
<br>
The purpose of the dispatched-to authentication handler is to provide a
custom implementation of the <code>getpwnam(3)</code> libc function.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/auth.c.html#auth_getpwnam">src/auth.c</a><br>

<hr>
<a name="auth_getgroups"><b>auth_getgroups</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  struct passwd *auth_getgroups(pool *<i>p</i>, const char *<i>name</i>, array_header **<i>group_ids</i>,
    array_header **<i>group_names</i>)
</pre>
<font color=blue>Comments</font>: Dispatcher for the
<code>getgroups()</code> authentication handler.<br>
<br>
The purpose of the dispatched-to authentication handler is to provide a
custom implementation of the <code>getgroups(2)</code> system call.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/auth.c.html#auth_getpwnam">src/auth.c</a><br>

<hr>
<a name="auth_getpwuid"><b>auth_getpwuid</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  struct passwd *auth_getpwuid(pool *<i>p</i>, uid_t <i>uid</i>)
</pre>
<font color=blue>Comments</font>: Dispatcher for the
<code>getpwuid()</code> authentication handler.<br>
<br>
The purpose of the dispatched-to authentication handler is to provide a
custom implementation of the <code>getpwuid(3)</code> libc function.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/auth.c.html#auth_getpwuid">src/auth.c</a><br>

<hr>
<a name="auth_gid_name"><b>auth_gid_name</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  const char *auth_gid_name(pool *<i>p</i>, gid_t <i>gid</i>)
</pre>
<font color=blue>Comments</font>: Dispatcher for the
<code>gid_name()</code> authentication handler.<br>
<br>
The purpose of the dispatched-to authentication handler is to do a
GID-to-name lookup for the given GID <i>gid</i>.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/auth.c.html#auth_gid_name">src/auth.c</a><br>

<hr>
<a name="auth_init"><b>auth_init</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int auth_init(void)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_auth.c.html#auth_init">modules/mod_auth.c</a><br>

<hr>
<a name="auth_login_timeout_cb"><b>auth_login_timeout_cb</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int auth_login_timeout_cb(CALLBACK_FRAME)
</pre>
<font color=blue>Comments</font>:  Timer callback function which disconnects
the control connection if the timer has elapsed before the client has
successfully authenticated.  The timer length is configurable via the
<code>TimeoutLogin</code> configuration directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_auth.c.html#auth_login_timeout_cb">modules/mod_auth.c</a><br>

<hr>
<a name="auth_name_gid"><b>auth_name_gid</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  gid_t auth_name_gid(pool *<i>p</i>, const char *<i>name</i>)
</pre>
<font color=blue>Comments</font>: Dispatcher for the
<code>name_gid()</code> authentication handler.<br>
<br>
The purpose of the dispatched-to authentication handler is to do a
name-to-GID lookup for the given group <i>name</i>.<br>
<br>
<font color=blue>Notes:</font> The caller of this function must take due
caution when handling the returned <code>gid_t</code>, and treat a
<code>gid_t</code> of <code>-1</code> properly.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/auth.c.html#auth_name_gid">src/auth.c</a><br>

<hr>
<a name="auth_name_uid"><b>auth_name_uid</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  uid_t auth_name_uid(pool *<i>p</i>, const char *<i>name</i>)
</pre>
<font color=blue>Comments</font>: Dispatcher for the
<code>name_uid()</code> authentication handler.<br>
<br>
The purpose of the dispatched-to authentication handler is to do a
name-to-UID lookup for the given user <i>name</i>.<br>
<br>
<font color=blue>Notes:</font> The caller of this function must take due
caution when handling the returned <code>uid_t</code>, and treat a
<code>uid_t</code> of <code>-1</code> properly.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/auth.c.html#auth_name_uid">src/auth.c</a><br>

<hr>
<a name="auth_pass"><b>auth_pass</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET auth_pass(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Command handler for the <code>PASS</code>
FTP command.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_auth.c.html#auth_pass">modules/mod_auth.c</a><br>

<hr>
<a name="auth_post_pass"><b>auth_post_pass</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET auth_post_pass(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_auth.c.html#auth_post_pass">modules/mod_auth.c</a><br>

<hr>
<a name="auth_pre_pass"><b>auth_pre_pass</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET auth_pre_pass(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_auth.c.html#auth_pre_pass">modules/mod_auth.c</a><br>

<hr>
<a name="auth_pre_user"><b>auth_pre_user</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET auth_pre_user(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_auth.c.html#auth_pre_user">modules/mod_auth.c</a><br>

<hr>
<a name="auth_rein"><b>auth_rein</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET auth_rein(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Command handler for the <code>REIN</code>
FTP command.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_auth.c.html#auth_rein">modules/mod_auth.c</a><br>

<hr>
<a name="auth_scan_scoreboard"><b>auth_scan_scoreboard</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static void auth_scan_scoreboard(void)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_auth.c.html#auth_scan_scoreboard">modules/mod_auth.c</a><br>

<hr>
<a name="auth_sess_init"><b>auth_sess_init</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int auth_sess_init(void)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_auth.c.html#auth_sess_init">modules/mod_auth.c</a><br>

<hr>
<a name="auth_setgrent"><b>auth_setgrent</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void auth_setgrent(pool *<i>p</i>)
</pre>
<font color=blue>Comments</font>: Dispatcher for the
<code>setgrent()</code> authentication handler.<br>
<br>
The purpose of the dispatched-to authentication handler is to provide a
custom implementation of the <code>setgrent(3)</code> libc function.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/auth.c.html#auth_setgrent">src/auth.c</a><br>

<hr>
<a name="auth_setpwent"><b>auth_setpwent</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void auth_setpwent(pool *<i>p</i>)
</pre>
<font color=blue>Comments</font>: Dispatcher for the
<code>setpwent()</code> authentication handler.<br>
<br>
The purpose of the dispatched-to authentication handler is to provide a
custom implementation of the <code>setpwent(3)</code> libc function.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/auth.c.html#auth_setpwent">src/auth.c</a><br>

<hr>
<a name="auth_uid_name"><b>auth_uid_name</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  const char *auth_uid_name(pool *<i>p</i>, uid_t <i>uid</i>)
</pre>
<font color=blue>Comments</font>: Dispatcher for the
<code>uid_name()</code> authentication handler.<br>
<br>
The purpose of the dispatched-to authentication handler is to do a
UID-to-name lookup for the given UID <i>uid</i>.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/auth.c.html#auth_uid_name">src/auth.c</a><br>

<hr>
<a name="auth_user"><b>auth_user</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET auth_user(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Command handler for the <code>USER</code>
FTP command.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_auth.c.html#auth_user">modules/mod_auth.c</a><br>


<hr>
<a name="block_alarms"><b>block_alarms</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void block_alarms(void)
</pre>
<font color=blue>Comments</font>: Blocks timers (which operate based on
<code>SIGALRM</code>) from being run.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/timers.c.html#block_alarms">src/timers.c</a><br>

<hr>
<a name="block_signals"><b>block_signals</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void block_signals(void)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/support.c.html#block_signals">src/support.c</a><br>

<hr>
<a name="build_dyn_config"><b>build_dyn_config</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void build_dyn_config(pool *<i>p</i>, char *<i>_path</i>, struct stat *<i>_sbuf</i>, int <i>recurse</i>)
</pre>
<font color=blue>Comments</font>:  This function looks through each
directory in <i>_path</i>, from the &quot;deepest&quot; up, looking for
new or updated <code>.ftpaccess</code> files.  All <code>.ftpaccess</code>
files are considered to be placed within a <code>&lt;Directory&gt;</code>;
within the <code>.ftpaccess</code> file itself, all configuration directives
are considered to be in a dynamic context
(<a href="macros.html#CONF_DYNDIR"><code>CONF_DYNDIR</code></a> to be
specific).  <code>.ftpaccess</code> files that have been updated are reparsed;
files that once contained directives, but are now empty or deleted are removed
from the configuration records.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#build_dyn_config">src/dirtree.c</a><br>

<hr>
<a name="bytes_in_block_list"><b>bytes_in_block_list</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  long bytes_in_block_list(union block_hdr *<i>blok</i>)
</pre>
<font color=blue>Comments</font>: Return the number of bytes in the given
<code>union block_header</code>.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/pool.c.html#bytes_in_block_list">src/pool.c</a><br>

<hr>
<a name="call_module"><b>call_module</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  modret_t *call_module(module *<i>m</i>, modret_t *(*<i>func</i>)(cmd_rec *), cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/modules.c.html#call_module">src/modules.c</a><br>

<hr>
<a name="call_module_auth"><b>call_module_auth</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  modret_t *call_module_auth(module *<i>mi</i>, modret_t *(*<i>func</i>)(cmd_rec *), cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/modules.c.html#call_module_auth">src/modules.c</a><br>

<hr>
<a name="call_module_cmd"><b>call_module_cmd</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  modret_t *call_module_cmd(module *<i>m</i>, modret_t *(*<i>func</i>)(cmd_rec *), cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/modules.c.html#call_module_cmd">src/modules.c</a><br>

<hr>
<a name="check_context"><b>check_context</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  unsigned char check_context(cmd_rec *<i>cmd</i>, int <i>allowed</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#check_context">src/dirtree.c</a><br>

<hr>
<a name="check_shutmsg"><b>check_shutmsg</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int check_shutmsg(time_t *<i>shut</i>, time_t *<i>deny</i>, time_t *<i>disc</i>, char *<i>msg</i>, size_t <i>msg_size</i>)
</pre>
<font color=blue>Comments</font>:  Checks for the existence of
<a href="macros.html#SHUTMSG_PATH"><code>SHUTMSG_PATH</code></a>, the
shutdown message file.  <i>deny</i> and <i>disc</i> are filled with the
times at which to deny new connections and to disconnect existing ones,
respectively.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/support.c.html#check_shutmsg">src/support.c</a><br>

<hr>
<a name="chk_on_blk_list"><b>chk_on_blk_list</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void chk_on_blk_list(union block_hdr *<i>blok</i>, union block_hdr *<i>free_blk</i>)
</pre>
<font color=blue>Comments</font>: A debugging function, it walks the given
<code>union block_hdr</code> <i>free_blk</i>, making sure that none of the
chained <code>union block_hdr</code>s point to <code>union block_hdr</code>
<i>blok</i>.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/pool.c.html#chk_on_blk_list">src/pool.c</a><br>

<hr>
<a name="clear_inet_pool"><b>clear_inet_pool</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void clear_inet_pool(void)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/inet.c.html#clear_inet_pool">src/inet.c</a><br>

<hr>
<a name="clear_pool"><b>clear_pool</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static void clear_pool(struct pool *<i>p</i>)
</pre>
<font color=blue>Comments</font>: Frees up the resources used by
<code>pool</code> <i>p</i>.  Does <b>not</b> destroy <code>pool</code>
<i>p</i> when finished.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/pool.c.html#clear_pool">src/pool.c</a><br>

<hr>
<a name="cmd_loop"><b>cmd_loop</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void cmd_loop(server_rec *<i>server</i>, conn_t *<i>c</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/main.c.html#cmd_loop">src/main.c</a><br>

<hr>
<a name="conn_cleanup_cb"><b>conn_cleanup_cb</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static void conn_cleanup_cb(void *<i>cv</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/inet.c.html#conn_cleanup_cb">src/inet.c</a><br>

<hr>
<a name="core_cdup"><b>core_cdup</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET core_cdup(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Command handler for the <code>CDUP</code>
FTP command.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#cmd_cdup">modules/mod_core.c</a><br>

<hr>
<a name="core_chgrp"><b>core_chgrp</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int core_chgrp(cmd_rec *<i>cmd</i>, char *<i>dir</i>, uid_t <i>uid</i>, gid_t <i>gid</i>)
</pre>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#core_chgrp">modules/mod_core.c</a><br>

<hr>
<a name="core_chmod"><b>core_chmod</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int core_chmod(cmd_rec *<i>cmd</i>, char *<i>dir</i>, mode_t <i>mode</i>)
</pre>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#core_chmod">modules/mod_core.c</a><br>

<hr>
<a name="core_cwd"><b>core_cwd</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET core_cwd(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Command handler for the <code>CWD</code>
and <code>XCWD</code> FTP commands.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#core_cwd">modules/mod_core.c</a><br>

<hr>
<a name="core_dele"><b>core_dele</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET core_dele(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Command handler for the <code>DELE</code>
FTP command.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#core_dele">modules/mod_core.c</a><br>

<hr>
<a name="core_help"><b>core_help</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET core_help(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Command handler for the <code>HELP</code>
FTP command.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#core_help">modules/mod_core.c</a><br>

<hr>
<a name="core_mdtm"><b>core_mdtm</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET cmd_mdtm(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Command handler for the <code>MDTM</code>
FTP command.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#cmd_mdtm">modules/mod_core.c</a><br>

<hr>
<a name="core_mkd"><b>core_mkd</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET core_mkd(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Command handler for the <code>MKD</code>
FTP command.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#core_mkd">modules/mod_core.c</a><br>

<hr>
<a name="core_netio_abort_cb"><b>core_netio_abort_cb</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static void core_netio_abort_cb(pr_netio_stream_t *<i>nstrm</i>)
</pre>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/netio.c.html#core_netio_abort_cb">src/netio.c</a><br>

<hr>
<a name="core_netio_close_cb"><b>core_netio_close_cb</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int core_netio_close_cb(pr_netio_stream_t *<i>nstrm</i>)
</pre>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/netio.c.html#core_netio_close_cb">src/netio.c</a><br>

<hr>
<a name="core_netio_open_cb"><b>core_netio_open_cb</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static pr_netio_stream_t *core_netio_open_cb(pr_netio_stream_t *<i>nstrm</i>, int <i>fd</i>, int <i>mode</i>)
</pre>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/netio.c.html#core_netio_open_cb">src/netio.c</a><br>

<hr>
<a name="core_netio_poll_cb"><b>core_netio_poll_cb</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int core_netio_poll_cb(pr_netio_stream_t *<i>nstrm</i>)
</pre>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/netio.c.html#core_netio_poll_cb">src/netio.c</a><br>

<hr>
<a name="core_netio_postopen_cb"><b>core_netio_postopen_cb</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int core_netio_postopen_cb(pr_netio_stream_t *<i>nstrm</i>)
</pre>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/netio.c.html#core_netio_postopen_cb">src/netio.c</a><br>

<hr>
<a name="core_netio_read_cb"><b>core_netio_read_cb</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int core_netio_read_cb(pr_netio_stream_t *<i>nstrm</i>, char *<i>buf</i>, size_t <i>buflen</i>)
</pre>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/netio.c.html#core_netio_read_cb">src/netio.c</a><br>

<hr>
<a name="core_netio_reopen_cb"><b>core_netio_reopen_cb</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
static pr_netio_stream_t *core_netio_reopen_cb(pr_netio_stream_t *<i>nstrm</i>, int <i>fd</i>, int <i>mode</i>)
</pre>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/netio.c.html#core_netio_reopen_cb">src/netio.c</a><br>

<hr>
<a name="core_netio_write_cb"><b>core_netio_write_cb</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int core_netio_write_cb(pr_netio_stream_t *<i>nstrm</i>, char *<i>buf</i>, size_t <i>buflen</i>)
</pre>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/netio.c.html#core_netio_write_cb">src/netio.c</a><br>

<hr>
<a name="core_noop"><b>core_noop</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET core_noop(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Command handler for the <code>NOOP</code>
FTP command.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#core_noop">modules/mod_core.c</a><br>

<hr>
<a name="core_pasv"><b>core_pasv</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET core_pasv(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Command handler for the <code>PASV</code>
FTP command.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#core_pasv">modules/mod_core.c</a><br>

<hr>
<a name="core_port"><b>core_port</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET core_port(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Command handler for the <code>PORT</code>
FTP command.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#core_port">modules/mod_core.c</a><br>

<hr>
<a name="core_pwd"><b>core_pwd</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET core_pwd(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Command handler for the <code>PWD</code>
FTP command.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#core_pwd">modules/mod_core.c</a><br>

<hr>
<a name="core_quit"><b>core_quit</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET core_quit(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Command handler for the <code>QUIT</code>
FTP command.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#core_quit">modules/mod_core.c</a><br>

<hr>
<a name="core_rehash_cb"><b>core_rehash_cb</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static void core_rehash_cb(void *<i>d1</i>, void *<i>d2</i>, void *<i>d3</i>, void *<i>d4</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/main.c.html#core_rehash_cb">src/main.c</a><br>

<hr>
<a name="core_rmd"><b>core_rmd</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET core_rmd(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Command handler for the <code>RMD</code>
FTP command.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#core_rmd">modules/mod_core.c</a><br>

<hr>
<a name="core_rnfr"><b>core_rnfr</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET core_rnfr(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Command handler for the <code>RNFR</code>
FTP command.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#core_rnfr">modules/mod_core.c</a><br>

<hr>
<a name="core_rnto"><b>core_rnto</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET core_rnto(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Command handler for the <code>RNTO</code>
FTP command.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#core_rnto">modules/mod_core.c</a><br>

<hr>
<a name="core_size"><b>core_size</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET core_size(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Command handler for the <code>SIZE</code>
FTP command.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#core_size">modules/mod_core.c</a><br>

<hr>
<a name="core_syst"><b>core_syst</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET core_syst(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Command handler for the <code>SYST</code>
FTP command.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#core_syst">modules/mod_core.c</a><br>

<hr>
<a name="cmp"><b>cmp</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int cmp(const void *<i>a</i>, const void *<i>b</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_ls.c.html#cmp">modules/mod_ls.c</a><br>

<hr>
<a name="copy_array"><b>copy_array</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  array_header *copy_array(pool *<i>p</i>, const array_header *<i>arr</i>)
</pre>
<font color=blue>Comments</font>: Returns a pointer to an
<code>array_header</code> that is a copy of <i>arr</i>, using resources from
<code>pool</code> <i>p</i>.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/pool.c.html#copy_array">src/pool.c</a><br>

<hr>
<a name="copy_array_hdr"><b>copy_array_hdr</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  array_header *copy_array_hdr(pool *<i>p</i>, const array_header *<i>arr</i>)
</pre>
<font color=blue>Comments</font>: Returns a pointer to an
<code>array_header</code> which contains duplicate pointers to the original
elements of <code>array_header</code> <i>arr</i>, using the resources of
<code>pool</code> <i>p</i>.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/pool.c.html#copy_array_hdr">src/pool.c</a><br>

<hr>
<a name="copy_array_str"><b>copy_array_str</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  array_header *copy_array_str(pool *<i>p</i>, const array_header *<i>arr</i>)
</pre>
<font color=blue>Comments</font>: Returns a pointer to an
<code>array_header</code> which contains duplicate elements (<i>i.e.</i>
strings) of the original elements of <code>array_header</code> <i>arr</i>,
allocated from the resources of <code>pool</code> <i>p</i>.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/pool.c.html#copy_array_str">src/pool.c</a><br>

<hr>
<a name="core_chmod"><b>core_chmod</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int core_chmod(cmd_rec *<i>cmd</i>, char *<i>dir</i>, mode_t <i>mode</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#core_chmod">modules/mod_core.c</a><br>

<hr>
<a name="core_display_file"><b>core_display_file</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int core_display_file(const char *<i>numeric</i>, const char *<i>fn</i>, const char *<i>fs</i>)
</pre>
<font color=blue>Comments</font>: Displays the file <i>fn</i>, which lives on
the filesystem <i>fs</i>, via the given response <i>numeric</i>.  The file is
displayed in normal RFC959 multiline mode, unless <code>MultilineRFC2228</code>
is set.<br>
<br>
This function returns <code>-1</code> on error, or <code>0</code> if the
file is displayed without trouble.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#core_display_file">modules/mod_core.c</a><br>

<hr>
<a name="daemonize"><b>daemonize</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static void daemonize(void)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/main.c.html#daemonize">src/main.c</a><br>

<hr>
<a name="data_abort"><b>data_abort</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void data_abort(int <i>err</i>, int <i>quiet</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/data.c.html#data_abort">src/data.c</a><br>

<hr>
<a name="data_cleanup"><b>data_cleanup</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void data_cleanup(void)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/data.c.html#data_cleanup">src/data.c</a><br>

<hr>
<a name="data_close"><b>data_close</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void data_close(int <i>quiet</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/data.c.html#data_close">src/data.c</a><br>

<hr>
<a name="data_init"><b>data_init</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void data_init(char *<i>filename</i>, int <i>direction</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/data.c.html#data_init">src/data.c</a><br>

<hr>
<a name="data_open"><b>data_open</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int data_open(char *<i>filename</i>, char *<i>reason</i>, int <i>direction</i>, unsigned long <i>size</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/data.c.html#data_open">src/data.c</a><br>

<hr>
<a name="data_reset"><b>data_reset</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void data_reset(void)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/data.c.html#data_reset">src/data.c</a><br>

<hr>
<a name="data_sendfile"><b>data_sendfile</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  pr_sendfile_t data_sendfile(int <i>retr_fd</i>, off_t *<i>offset</i>, size_t <i>count</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/data.c.html#data_sendfile">src/data.c</a><br>

<hr>
<a name="data_urgent"><b>data_urgent</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  RETSIGTYPE data_urgent(int <i>sig</i>)
</pre>
<font color=blue>Comments</font>:  Signal handler for the <code>SIGURG</code>
signal, to be raised if OOB data is received on the control connection while
a data transfer is in progress.  This handler sets the <code>SF_ABORT</code>
session flag and aborts the current transfer.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/data.c.html#data_urgent">src/data.c</a><br>

<hr>
<a name="data_xfer"><b>data_xfer</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int data_xfer(char *<i>cl_buf</i>, int <i>cl_size</i>)
</pre>
<font color=blue>Comments</font>:  This function actually performs the work
of transferring data on the data connection.  ASCII translation is performed
if necessary.  The direction of the transfer, set when the data connection
was opened, determines whether the client buffer <i>cl_buf</i> is read from
or written to.<br>
<br>
Returns <code>0</code> if successful, or if reading and the data connection
closes; <code>-1</code> on error.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/data.c.html#data_xfer">src/data.c</a><br>

<hr>
<a name="debug_dump_config"><b>debug_dump_config</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void debug_dump_config(xaset_t *<i>s</i>, char *<i>indent</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#debug_dump_config">src/dirtree.c</a><br>

<hr>
<a name="debug_pool_info"><b>debug_pool_info</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void debug_pool_info(void)
</pre>
<font color=blue>Comments</font>: Debugging function, for debugging pool
resource management.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/pool.c.html#debug_pool_info">src/pool.c</a><br>

<hr>
<a name="debug_walk_pools"><b>debug_walk_pools</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void debug_walk_pools(void)
</pre>
<font color=blue>Comments</font>: Self-explanatory function, it does just what
its name says.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/pool.c.html#debug_walk_pools">src/pool.c</a><br>

<hr>
<a name="destroy_pool"><b>destroy_pool</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void destroy_pool(pool *<i>p</i>)
</pre>
<font color=blue>Comments</font>: Completely frees the resources used by
<code>pool</code> <i>p</i> and its subpools.  Destroys the <code>pool</code>
<i>p</i> when finished.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/pool.c.html#destroy_pool">src/pool.c</a><br>

<hr>
<a name="dir_abs_path"><b>dir_abs_path</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  char *dir_abs_path(pool *<i>p</i>, const char *<i>path</i>, int <i>interpolate</i>)
</pre>
<font color=blue>Comments</font>:  Takes a directory <i>path</i> and returns
its corresponding <i>absolute</i> path, which is based on the root
directory, not on a <code>chroot</code>ed directory (<i>i.e.</i>
<code>chroot()</code> does <b>not</b> affect the absolute path).
If <i>interpolate</i> is <code>TRUE</code>, <code>~username</code> references
will be interpolated appropriately.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/support.c.html#dir_abs_path">src/support.c</a><br>

<hr>
<a name="dir_best_path"><b>dir_best_path</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  char *dir_best_path(pool *<i>p</i>, const char *<i>path</i>)
</pre>
<font color=blue>Comments</font>:  This function creates the <i>most</i>
fully canonicalized path possible, <i>i.e.</i> if path components at the end
of <i>path</i> do not exist, they are ignored.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/support.c.html#dir_best_path">src/support.c</a><br>

<hr>
<a name="dir_canonical_path"><b>dir_canonical_path</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  char *dir_canonical_path(pool *<i>p</i>, const char *<i>path</i>)
</pre>
<font color=blue>Comments</font>:  Takes a directory <i>path</i> and returns
its corresponding <i>canonical</i> path, which is based on the current
working directory (<i>i.e.</i> <code>chroot()</code> does affect the canonical
path).  <code>~username</code> references are interpolated.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/support.c.html#dir_canonical_path">src/support.c</a><br>

<hr>
<a name="dir_check"><b>dir_check</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int dir_check(pool *<i>pp</i>, char *<i>cmd</i>, char *<i>group</i>, char *<i>path</i>, int *<i>hidden</i>)
</pre>
<font color=blue>Comments</font>: This function checks the current directory
configuration against the given path.  If the current directory partially
matches the path, a search is done only in the contained sub-configurations,
otherwise the check is handed off to
<a href="#dir_check_full"><code>dir_check_full()</code></a>.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#dir_check">src/dirtree.c</a><br>

<hr>
<a name="dir_check_canon"><b>dir_check_canon</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int dir_check_canon(pool *<i>pp</i>, char *<i>cmd</i>, char *<i>group</i>, char *<i>path</i>, int *<i>hidden</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#dir_check_canon">src/dirtree.c</a><br>

<hr>
<a name="dir_check_full"><b>dir_check_full</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int dir_check_full(pool *<i>pp</i>, char *<i>cmd</i>, char *<i>group</i>, char *<i>path</i>, int *<i>hidden</i>)
</pre>
<font color=blue>Comments</font>: This function fully walks the given
<i>path</i>.<br>
<br>
It returns <code>TRUE</code> if an operation is allowed on the current
<i>path</i>, else it returns <code>FALSE</code>.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#dir_check_full">src/dirtree.c</a><br>

<hr>
<a name="dir_check_limits"><b>dir_check_limits</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int dir_check_limits(config_rec *<i>c</i>, char *<i>cmd</i>, int <i>hidden</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#dir_check_limits">src/dirtree.c</a><br>

<hr>
<a name="dir_check_op_mode"><b>dir_check_op_mode</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int dir_check_op_mode(pool *<i>p</i>, char *<i>path</i>, int <i>op</i>, int <i>uid</i>, int <i>gid</i>, int <i>mode</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#dir_check_op_mode">src/dirtree.c</a><br>

<hr>
<a name="dir_exists"><b>dir_exists</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int dir_exists(char *<i>path</i>)
</pre>
<font color=blue>Comments</font>: Returns <code>TRUE</code> if <i>path</i>
exists and is a directory, <code>FALSE</code> otherwise.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/support.c.html#dir_exists">src/support.c</a><br>

<hr>
<a name="dir_hide_file"><b>dir_hide_file</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  unsigned char dir_hide_file(const char *<i>path</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#dir_hide_file">src/dirtree.c</a><br>

<hr>
<a name="dir_interpolate"><b>dir_interpolate</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  char *dir_interpolate(pool *<i>p</i>, const char *<i>path</i>)
</pre>
<font color=blue>Comments</font>:  This function interpolates the given
<i>path</i>, expanding the <code>~</code> notation if necessary.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/support.c.html#dir_interpolate">src/support.c</a><br>

<hr>
<a name="dir_match_path"><b>dir_match_path</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  config_rec *dir_match_path(pool *<i>p</i>, char *<i>path</i>)
</pre>
<font color=blue>Comments</font>: If the given <i>path</i> ends in
&quot;*&quot;, strip it off.  Then, if <i>path</i> ends in &quot;/&quot;,
strip it off, too.<br>
<br>
<font color=blue>Notes</font>: For this function to work correctly, the
<i>path</i> given <b><i>must be an absolute path</i></b>.  This is particularly
important when working with paths during anonymous sessions, for in such
sessions the paths are modified by the <code>chroot()</code>ing of anonymous
sessions.  As in other places in the core code, it is wise to have logic such
as this <i>before</i> calling <code>dir_match_path()</code>:
<pre>
    config_rec *dir_config = NULL;
    char *fullpath = path;

    if (session.anon_config)
      fullpath = pdircat(p, session.anon_root, path, NULL);

    dir_config = dir_match_path(p, fullpath);
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#dir_match_path">src/dirtree.c</a><br>

<hr>
<a name="dir_realpath"><b>dir_realpath</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  char *dir_realpath(pool *<i>p</i>, const char *<i>path</i>)
</pre>
<font color=blue>Comments</font>:  This function is needed to properly
dereference symlinks, for <a href="#fs_getcwd"><code>fs_getcwd()</code></a>
may not work if permissions cause problems somewhere up the tree.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/support.c.html#dir_realpath">src/support.c</a><br>

<hr>
<a name="dir_virtual_chdir"><b>dir_virtual_chdir</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  char *dir_virtual_chdir(pool *<i>p</i>, const char *<i>path</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/support.c.html#dir_virtual_chdir">src/support.c</a><br>

<hr>
<a name="disc_children"><b>disc_children</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void disc_children(void)
</pre>
<font color=blue>Comments</font>: This function causes <code>SIGUSR1</code>
to be sent to all children processed, terminating them, thus
&quot;disconnecting&quot: those clients.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/main.c.html#disc_children">src/main.c</a><br>

<hr>
<a name="discard_output"><b>discard_output</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void discard_output(void)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_ls.c.html#discard_output">modules/mod_ls.c</a><br>

<hr>
<a name="dispatch_cmd"><b>dispatch_cmd</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static void dispatch_cmd(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/main.c.html#dispatch_cmd">src/main.c</a><br>

<hr>
<a name="do_log"><b>do_log</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void do_log(cmd_rec *<i>cmd</i>, logfile_t *<i>lf</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_log.c.html#do_log">modules/mod_log.c</a><br>

<hr>
<a name="dolist"><b>dolist</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int dolist(cmd_rec *<i>cmd</i>, const char *<i>opt</i>, int <i>clearflags</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_ls.c.html#dolist">modules/mod_ls.c</a><br>

<hr>
<a name="end_anonymous"><b>end_anonymous</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET end_anonymous(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>&lt;/Anonymous&gt;</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#end_anonymous">modules/mod_core.c</a><br>

<hr>
<a name="end_directory"><b>end_directory</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET end_directory(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>&lt;/Directory&gt;</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#end_directory">modules/mod_core.c</a><br>

<hr>
<a name="end_ifdefine"><b>end_ifdefine</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET end_ifdefine(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>&lt;/IfDefine&gt;</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#end_ifdefine">modules/mod_core.c</a><br>

<hr>
<a name="end_ifmodule"><b>end_ifmodule</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET end_ifmodule(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>&lt;/IfModule&gt;</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#end_ifmodule">modules/mod_core.c</a><br>

<hr>
<a name="end_global"><b>end_global</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET end_global(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>&lt;/Global&gt;</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#end_global">modules/mod_core.c</a><br>

<hr>
<a name="end_limit"><b>end_limit</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET end_limit(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>&lt;/Limit&gt;</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#end_limit">modules/mod_core.c</a><br>

<hr>
<a name="end_login"><b>end_login</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void end_login(int <i>exitcode</i>)
</pre>
<font color=blue>Comments</font>: Function used for terminating a session.
The child process servicing the current session exits with the given
<i>exitcode</i>. <a href="#end_login_noexit"><code>end_login_noexit()</code></a>
is invoked before <code>_exit()</code> is used to terminate the process.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/main.c.html#end_login">src/main.c</a><br>

<hr>
<a name="end_login_noexit"><b>end_login_noexit</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void end_login_noexit(void)
</pre>
<font color=blue>Comments</font>: As part of a session termination, this
function is called.  All registered exit handlers are run, and all necessary
log files are closed.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/main.c.html#end_login_noexit">src/main.c</a><br>

<hr>
<a name="end_new_server"><b>end_new_server</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  server_rec *end_new_server(void)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#end_new_server">src/dirtree.c</a><br>

<hr>
<a name="end_sub_config"><b>end_sub_config</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  config_rec *end_sub_config(void)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#end_sub_config">src/dirtree.c</a><br>

<hr>
<a name="end_virtualhost"><b>end_virtualhost</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET end_virtualhost(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#end_virtualhost">modules/mod_core.c</a><br>

<hr>
<a name="ensure_open_passwd"><b>ensure_open_passwd</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static void ensure_open_passwd(pool *<i>p</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_auth.c.html#ensure_open_passwd">modules/mod_auth.c</a><br>

<hr>
<a name="exists"><b>exists</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int exists(char *<i>path</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/support.c.html#exists">src/support.c</a><br>

<hr>
<a name="fd_cleanup_cb"><b>fd_cleanup_cb</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static void fd_cleanup_cb(void *<i>fdv</i>)
</pre>
<font color=blue>Comments</font>: <code>close()</code>s the file descriptor
<i>fdv</i>.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/pool.c.html#fd_cleanup_cb">src/pool.c</a><br>

<hr>
<a name="fgetbufline"><b>fgetbufline</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static char *fgetbufline(char **<i>buf</i>, int *<i>size</i>, FILE *<i>fp</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/lib/pwgrent.c.html#fgetbufline">lib/pwgrent.c</a><br>

<hr>
<a name="fgetgrent"><b>fgetgrent</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  struct group *fgetgrent(FILE *<i>fp</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/lib/pwgrent.c.html#fgetgrent">lib/pwgrent.c</a><br>

<hr>
<a name="fgetpwent"><b>fgetpwent</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  struct passwd *fgetpwent(FILE *<i>fp</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/lib/pwgrent.c.html#fgetpwent">lib/pwgrent.c</a><br>

<hr>
<a name="file_child_cleanup_cb"><b>file_child_cleanup_cb</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static void file_child_cleanup_cb(void *<i>fpv</i>)
</pre>
<font color=blue>Comments</font>: <code>close()</code>s the file pointed to
by <code>FILE</code> pointer <i>fpv</i>.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/pool.c.html#file_child_cleanup_cb">src/pool.c</a><br>

<hr>
<a name="file_cleanup_cb"><b>file_cleanup_cb</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static void file_cleanup_cb(void *<i>fpv</i>)
</pre>
<font color=blue>Comments</font>: <code>fclose()</code>s the file pointed
to by <code>FILE</code> pointer <i>fpv</i>.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/pool.c.html#file_cleanup_cb">src/pool.c</a><br>

<hr>
<a name="file_exists"><b>file_exists</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int file_exists(char *<i>path</i>)
</pre>
<font color=blue>Comments</font>: Returns <code>TRUE</code> if <i>path</i>
exists, <code>FALSE</code> otherwise.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/support.c.html#file_exists">src/support.c</a><br>

<hr>
<a name="file_mode"><b>file_mode</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  mode_t file_mode(char *<i>path</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/support.c.html#file_mode">src/support.c</a><br>

<hr>
<a name="find_binding"><b>find_binding</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  server_rec *find_binding(p_in_addr_t *<i>ipaddr</i>, int <i>port</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/main.c.html#find_binding">src/main.c</a><br>

<hr>
<a name="find_cdir"><b>find_cdir</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static cdir_t *find_cdir(u_int_32 <i>address</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#find_cdir">modules/mod_core.c</a><br>

<hr>
<a name="find_class"><b>find_class</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  class_t *find_class(p_in_addr_t *<i>addr</i>, char *<i>remote_name</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#find_class">modules/mod_core.c</a><br>

<hr>
<a name="find_config"><b>find_config</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  config_rec *find_config(xaset_t *<i>set</i>, int <i>type</i>, const char *<i>name</i>, int <i>recurse</i>)
</pre>
<font color=blue>Comments</font>: The <i>recurse</i> parameter should almost
always be <code>FALSE</code>.  Exceptions to this rule are very rare.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#find_config">src/dirtree.c</a><br>

<hr>
<a name="find_config_next"><b>find_config_next</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  config_rec *find_config_next(config_rec *<i>prev</i>, config_rec *<i>c</i>, int <i>type</i>, const char *<i>name</i>,
    int <i>recurse</i>)
</pre>
<font color=blue>Comments</font>: The <i>recurse</i> parameter should almost
always be <code>FALSE</code>.  Exceptions to this rule are very rare.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#find_config_next">src/dirtree.c</a><br>

<hr>
<a name="find_config_set_top"><b>find_config_set_top</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void find_config_set_top(config_rec *<i>c</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#find_config_set_top">src/dirtree.c</a><br>

<hr>
<a name="find_hostname"><b>find_hostname</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static hostname_t *find_hostname(char *<i>name</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#find_hostname">modules/mod_core.c</a><br>

<hr>
<a name="find_opendir"><b>find_opendir</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static fsdir_t *find_opendir(void *<i>d</i>, int <i>closing</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#find_opendir">src/fs.c</a><br>

<hr>
<a name="fixup_dirs"><b>fixup_dirs</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void fixup_dirs(server_rec *<i>s</i>, int <i>mask</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#fixup_dirs">src/dirtree.c</a><br>

<hr>
<a name="fixup_globals"><b>fixup_globals</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void fixup_globals(void)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#fixup_globals">src/dirtree.c</a><br>

<hr>
<a name="fixup_servers"><b>fixup_servers</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void fixup_servers(void)
</pre>
<font color=blue>Comments</font>: Go through each server configuration and
complain if important information is missing, after the configuration file(s)
have been read.  Otherwise, fill in default values where applicable.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#fixup_servers">src/dirtree.c</a><br>

<hr>
<a name="fmt_time"><b>fmt_time</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  char *fmt_time(time_t <i>t</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/log.c.html#fmt_time">src/log.c</a><br>

<hr>
<a name="fork_server"><b>fork_server</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static void fork_server(int <i>fd</i>, conn_t *<i>l</i>, int <i>nofork</i>)
</pre>
<font color=blue>Comments</font>: Forks a child process to handle the session
for the requesting client, installing signal handlers and preparing the
child process' space for processing client commands.  If <i>nofork</i> is
<code>TRUE</code>, does not actually fork; this is used mostly for debugging
purposes.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/main.c.html#fork_server">src/main.c</a><br>

<hr>
<a name="free_blocks"><b>free_blocks</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void free_blocks(union block_hdr *<i>blok</i>)
</pre>
<font color=blue>Comments</font>: Free a chain of <code>union block_hdr</code>s.
Alarms <b>must</b> be blocked before calling this function.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/pool.c.html#free_blocks">src/pool.c</a><br>

<hr>
<a name="free_conf_stacks"><b>free_conf_stacks</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void free_conf_stacks(void)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#free_conf_stacks">src/dirtree.c</a><br>

<hr>
<a name="free_dyn_stacks"><b>free_dyn_stacks</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void free_dyn_stacks(void)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#free_dyn_stacks">src/dirtree.c</a><br>

<hr>
<a name="fs_chdir"><b>fs_chdir</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int fs_chdir(const char *<i>path</i>, int <i>hidesymlink</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#fs_chdir">src/fs.c</a><br>

<hr>
<a name="fs_chdir_canon"><b>fs_chdir_canon</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int fs_chdir_canon(const char *<i>path</i>, int <i>hidesymlink</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#fs_chdir_canon">src/fs.c</a><br>

<hr>
<a name="fs_chmod"><b>fs_chmod</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int fs_chmod(const char *<i>name</i>, mode_t <i>mode</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#fs_chmod">src/fs.c</a><br>

<hr>
<a name="fs_chmod_canon"><b>fs_chmod_canon</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int fs_chmod_canon(const char *<i>name</i>, mode_t <i>mode</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#fs_chmod_canon">src/fs.c</a><br>

<hr>
<a name="fs_chown"><b>fs_chown</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int fs_chown(const char *<i>name</i>, uid_t <i>uid</i>, gid_t <i>gid</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#fs_chown">src/fs.c</a><br>

<hr>
<a name="fs_chown_canon"><b>fs_chown_canon</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int fs_chown_canon(const char *<i>name</i>, uid_t <i>uid</i>, gid_t <i>gid</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#fs_chown_canon">src/fs.c</a><br>

<hr>
<a name="fs_clean_path"><b>fs_clean_path</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void fs_clean_path(const char *<i>path</i>, char *<i>buf</i>, int <i>maxlen</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#fs_clean_path">src/fs.c</a><br>

<hr>
<a name="fs_close"><b>fs_close</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int fs_close(fsdir_t *<i>f</i>, int <i>fd</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#fs_close">src/fs.c</a><br>

<hr>
<a name="fs_closedir"><b>fs_closedir</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int fs_closedir(void *<i>d</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#fs_closedir">src/fs.c</a><br>

<hr>
<a name="fs_creat"><b>fs_creat</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  fsdir_t *fs_creat(const char *<i>name</i>, mode_t <i>mode</i>, int *<i>fd</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#fs_creat">src/fs.c</a><br>

<hr>
<a name="fs_creat_canon"><b>fs_creat_canon</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  fsdir_t *fs_creat_canon(const char *<i>name</i>, mode_t <i>mode</i>, int *<i>fd</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#fs_creat_canon">src/fs.c</a><br>

<hr>
<a name="fs_dircat"><b>fs_dircat</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void fs_dircat(char *<i>buf</i>, int <i>len</i>, const char *<i>dir1</i>, const char *<i>dir2</i>)
</pre>
<font color=blue>Comments</font>:  Concatenates <i>dir1</i> and <i>dir2</i>,
and places the results in <i>buf</i>, where <i>len</i> indicates the size
of <i>buf</i>.  If the concatenated path would be longer than
<code>MAXPATHLEN</code>, then <i>buf</i> will default to &quot;/&quot;.<br>
<br>
<font color=blue>Notes</font>: This function uses <code>strdup()</code> and
<code>free()</code>, rather than <code>pool</code>s, for memory, thus breaking
the general rule of using <code>pool</code>s.  This is done intentionally in
this function for performance reasons, as this function is highly utilized.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#fs_dircat">src/fs.c</a><br>

<hr>
<a name="fs_getcwd"><b>fs_getcwd</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  const char *fs_getcwd(void)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#fs_getcwd">src/fs.c</a><br>

<hr>
<a name="fs_gets"><b>fs_gets</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  char *fs_gets(char *<i>buf</i>, size_t <i>size</i>, fsdir_t *<i>f</i>, int <i>fd</i>)
</pre>
<font color=blue>Comments</font>:  This function is not truly a virtual
filesystem function.  However, it is included here for simplicity.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#fs_gets">src/fs.c</a><br>

<hr>
<a name="fs_getvwd"><b>fs_getvwd</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  const char *fs_getvwd(void)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#fs_getvwd">src/fs.c</a><br>

<hr>
<a name="fs_glob"><b>fs_glob</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int fs_glob(const char *<i>pattern</i>, int <i>flags</i>, int (*<i>errfunc</i>)(const char *, int), glob_t *<i>pglob</i>)
</pre>
<font color=blue>Comments</font>: <code>fs_glob</code> is just a wrapper for
<code>glob</code>, setting the various <code>gl_</code> callbacks to our
FS functions<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#fs_glob">src/fs.c</a><br>

<hr>
<a name="fs_globfree"><b>fs_globfree</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void fs_globfree(glob_t *<i>pglob</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#fs_globfree">src/fs.c</a><br>

<hr>
<a name="fs_interpolate"><b>fs_interpolate</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int fs_interpolate(const char *<i>path</i>, char *<i>buf</i>, int <i>maxlen</i>)
</pre>
<font color=blue>Comments</font>:  This function performs any tilde expansion
needed, then returns the resolved path, if any.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#fs_interpolate">src/fs.c</a><br>

<hr>
<a name="fs_link"><b>fs_link</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int fs_link(const char *<i>lfrom</i>, const char *<i>lto</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#fs_link">src/fs.c</a><br>

<hr>
<a name="fs_link_canon"><b>fs_link_canon</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int fs_link_canon(const char *<i>lfrom</i>, const char *<i>lto</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#fs_link_canon">src/fs.c</a><br>

<hr>
<a name="fs_lookup_dir"><b>fs_lookup_dir</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  fsdir_t *fs_lookup_dir(const char *<i>path</i>, int <i>op</i>)
</pre>
<font color=blue>Comments</font>:  This function is called whenever any
sort of directory operation, to be performed on a directory or file, is
needed.  A &quot;closest&quot; match algorithm is used.  If the lookup
fails or is not &quot;close enough&quot; (<i>i.e.</i> the final target does
not exactly match an existing <code>fsdir_t</code>), we can look for
matchable targets and call <code>file_hit</code>, then rescan the
<code>fsdir_t</code> list.  The rescan is performed in case any modules
registered FS handlers during the hit.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#fs_lookup_dir">src/fs.c</a><br>

<hr>
<a name="fs_lookup_file"><b>fs_lookup_file</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  fsdir_t *fs_lookup_file(const char *<i>path</i>, char **<i>deref</i>, int <i>op</i>)
</pre>
<font color=blue>Comments</font>:  This functions performs a similar function
to <a href="#fs_lookup_dir"><code>fs_lookup_dir()</code></a>, however, as
it performs a <i>file</i> lookup, as opposed to a <i>directory</i> lookup,
the target is the subdirectory containing the actual target <i>path</i>.
A basic optimization - if the path contains no slashes,
<a href="#fs_cwd"><code>fs_cwd()</code></a> is returned - is used.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#fs_lookup_file">src/fs.c</a><br>

<hr>
<a name="fs_lookup_file_canon"><b>fs_lookup_file_canon</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  fsdir_t *fs_lookup_file_canon(const char *<i>path</i>, char **<i>deref</i>, int <i>op</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#fs_lookup_file_canon">src/fs.c</a><br>

<hr>
<a name="fs_lseek"><b>fs_lseek</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  off_t fs_lseek(fsdir_t *<i>f</i>, int <i>fd</i>, off_t <i>offset</i>, int <i>whence</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#fs_lseek">src/fs.c</a><br>

<hr>
<a name="fs_lstat"><b>fs_lstat</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int fs_lstat(const char *<i>path</i>, struct stat *<i>sbuf</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#fs_lstat">src/fs.c</a><br>

<hr>
<a name="fs_lstat_canon"><b>fs_lstat_canon</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int fs_lstat_canon(const char *<i>path</i>, struct stat *<i>sbuf</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#fs_lstat_canon">src/fs.c</a><br>

<hr>
<a name="fs_open"><b>fs_open</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  fsdir_t *fs_open(const char *<i>name</i>, int <i>flags</i>, int *<i>fd</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#fs_open">src/fs.c</a><br>

<hr>
<a name="fs_open_canon"><b>fs_open_canon</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  fsdir_t *fs_open_canon(const char *<i>name</i>, int <i>flags</i>, int *<i>fd</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#fs_open_canon">src/fs.c</a><br>

<hr>
<a name="fs_opendir"><b>fs_opendir</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void *fs_opendir(const char *<i>path</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#fs_opendir">src/fs.c</a><br>

<hr>
<a name="fs_read"><b>fs_read</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int fs_read(fsdir_t *<i>f</i>, int <i>fd</i>, char *<i>buf</i>, size_t <i>size</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#fs_read">src/fs.c</a><br>

<hr>
<a name="fs_readdir"><b>fs_readdir</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  struct dirent *fs_readdir(void *<i>d</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#fs_readdir">src/fs.c</a><br>

<hr>
<a name="fs_readlink"><b>fs_readlink</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int fs_readlink(const char *<i>path</i>, char *<i>buf</i>, int <i>maxlen</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#fs_readlink">src/fs.c</a><br>

<hr>
<a name="fs_readlink_canon"><b>fs_readlink_canon</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int fs_readlink_canon(const char *<i>path</i>, char *<i>buf</i>, int <i>maxlen</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#fs_readlink_canon">src/fs.c</a><br>

<hr>
<a name="fs_register"><b>fs_register</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  fsdir_t *fs_register(char *<i>name</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#fs_register">src/fs.c</a><br>

<hr>
<a name="fs_register_match"><b>fs_register_match</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  fsmatch_t *fs_register_match(char *<i>name</i>, int <i>opmask</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#fs_register_match">src/fs.c</a><br>

<hr>
<a name="fs_rename"><b>fs_rename</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int fs_rename(const char *<i>rfrom</i>, const char *<i>rto</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#fs_rename">src/fs.c</a><br>

<hr>
<a name="fs_rename_canon"><b>fs_rename_canon</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int fs_rename_canon(const char *<i>rfrom</i>, const char *<i>rto</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#fs_rename_canon">src/fs.c</a><br>

<hr>
<a name="fs_resolve_partial"><b>fs_resolve_partial</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int fs_resolve_partial(const char *<i>path</i>, char *<i>buf</i>, int <i>maxlen</i>, int <i>op</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#fs_resolve_partial">src/fs.c</a><br>

<hr>
<a name="fs_resolve_path"><b>fs_resolve_path</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int fs_resolve_path(const char *<i>path</i>, char *<i>buf</i>, int <i>maxlen</i>, int <i>op</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#fs_resolve_path">src/fs.c</a><br>

<hr>
<a name="fs_setcwd"><b>fs_setcwd</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void fs_setcwd(const char *<i>dir</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#fs_setcwd">src/fs.c</a><br>

<hr>
<a name="fs_stat"><b>fs_stat</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int fs_stat(const char *<i>path</i>, struct stat *<i>sbuf</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#fs_stat">src/fs.c</a><br>

<hr>
<a name="fs_stat_canon"><b>fs_stat_canon</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int fs_stat_canon(const char *<i>path</i>, struct stat *<i>sbuf</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#fs_stat_canon">src/fs.c</a><br>

<hr>
<a name="fs_symlink"><b>fs_symlink</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int fs_symlink(const char *<i>lfrom</i>, const char *<i>lto</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#fs_symlink">src/fs.c</a><br>

<hr>
<a name="fs_symlink_canon"><b>fs_symlink_canon</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int fs_symlink_canon(const char *<i>lfrom</i>, const char *<i>lto</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#fs_symlink_canon">src/fs.c</a><br>

<hr>
<a name="fs_unlink"><b>fs_unlink</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int fs_unlink(const char *<i>name</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#fs_unlink">src/fs.c</a><br>

<hr>
<a name="fs_unlink_canon"><b>fs_unlink_canon</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int fs_unlink_canon(const char *<i>name</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#fs_unlink_canon">src/fs.c</a><br>

<hr>
<a name="fs_virtual_path"><b>fs_virtual_path</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void fs_virtual_path(const char *<i>path</i>, char *<i>buf</i>, int <i>maxlen</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#fs_virtual_path">src/fs.c</a><br>

<hr>
<a name="fs_write"><b>fs_write</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int fs_write(fsdir_t *<i>f</i>, int <i>fd</i>, const char *<i>buf</i>, size_t <i>size</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#fs_write">src/fs.c</a><br>

<hr>
<a name="genericlist"><b>genericlist</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET genericlist(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_ls.c.html#genericlist">modules/mod_ls.c</a><br>

<hr>
<a name="get_boolean"><b>get_boolean</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int get_boolean(cmd_rec *<i>cmd</i>, int <i>av</i>)
</pre>
<font color=blue>Comments</font>: Check the <i>av</i> argument string in the
given <i>cmd</i> as a Boolean value, using a case-insensitive comparison.
Valid Boolean strings are: <code>on</code>, <code>off</code>, <code>yes</code>,
<code>no</code>, <code>true</code>, <code>false</code>, <code>1</code>, and
<code>0</code>.  Returns <code>1</code> if the checked string is a Boolean
<code>TRUE</code>, <code>0</code> if it is a Boolean <code>FALSE</code>, and
<code>-1</code> to signal that the string is not one of the recognized Boolean
strings.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#get_boolean">src/dirtree.c</a><br>

<hr>
<a name="get_class"><b>get_class</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static class_t *get_class(char *<i>name</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#get_class">modules/mod_core.c</a><br>

<hr>
<a name="get_command_class"><b>get_command_class</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int get_command_class(const char *<i>name</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/main.c.html#get_command_class">src/main.c</a><br>

<hr>
<a name="get_config_cmd"><b>get_config_cmd</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  cmd_rec *get_config_cmd(pool *<i>ppool</i>, FILE *<i>fp</i>, int *<i>line</i>)
</pre>
<font color=blue>Comments</font>:  Reads in a single line from the
configuration file <i>fp</i>, then parses that line of text into a configuration
directive in the form of a
<a href="structs.html#cmd_rec"><code>cmd_rec</code></a> (allocated from
the given <code>pool</code> <i>ppool</i>) which is then
dispatched to the appropriate configuration directive handler.  <i>line</i>
is used to track the current line number being parsed from the configuration
file.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#get_config_cmd">src/dirtree.c</a><br>

<hr>
<a name="get_context_name"><b>get_context_name</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  char *get_context_name(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Returns a string describing the context
in which <i>cmd</i> appears; utilized mostly by configuration directive
handler functions.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#get_context_name">src/dirtree.c</a><br>

<hr>
<a name="get_extendedlogs"><b>get_extendedlogs</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static void get_extendedlogs(void)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_log.c.html#get_extendedlogs">modules/mod_log.c</a><br>

<hr>
<a name="get_fs_size"><b>get_fs_size</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  unsigned long get_fs_size(char *<i>s</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/support.c.html#get_fs_size">src/support.c</a><br>

<hr>
<a name="get_full_cmd"><b>get_full_cmd</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  char *get_full_cmd(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Returns a string containing the full
command issued by a client, including command arguments.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#get_full_cmd">src/dirtree.c</a><br>

<hr>
<a name="get_ident"><b>get_ident</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  char *get_ident(pool *<i>p</i>, conn_t *<i>c</i>)
</pre>
<font color=blue>Comments</font>:  Returns the identity of the remote user,
as determined by the RFC 1413 ident protocol.  Returns
<code>&quot;UNKNOWN&quot;</code> if the lookup timeouts or fails.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/ident.c.html#get_ident">src/ident.c</a><br>

<hr>
<a name="get_name_max"><b>get_name_max</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  get_name_max(char *<i>dirname</i>, int <i>dir_fd</i>)
</pre>
<font color=blue>Comments</font>:  Get the maximum size of a file name,
specifically of the pathname component.  If a directory file descriptor,
<i>ie</i> the <code>dir_fd</code> <code>DIR</code> structure element, is
not available, then the second argument should be <code>0</code>.<br>
<br>
<font color=blue>Notes</font>: A POSIX compliant system typically should
<b>not</b> define <code>NAME_MAX</code>, since the value almost certainly
varies across different file system types.  Refer to POSIX 1003.1a,
Section 2.9.5, Table 2-5.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/support.c.html#get_name_max">src/support.c</a><br>

<hr>
<a name="get_next_meta"><b>get_next_meta</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static char *get_next_meta(pool *<i>p</i>, cmd_rec *<i>cmd</i>, unsigned char **<i>f</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_log.c.html#get_next_meta">modules/mod_log.c</a><br>

<hr>
<a name="get_num_bytes"><b>get_num_bytes</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static ssize_t get_num_bytes(char *<i>nbytes_str</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#get_num_bytes">modules/mod_core.c</a><br>

<hr>
<a name="get_param_int"><b>get_param_int</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  long get_param_int(xaset_t *<i>set</i>, const char *<i>name</i>, int <i>recurse</i>)
</pre>
<font color=blue>Comments</font>:  This function returns the first argument
in a <a href="macros.html#CONF_PARAM"><code>CONF_PARAM</code></a> configuration
record.  If more than one, or all, arguments are needed, the caller will
need to use <a href="#find_config"><code>find_config()</code></a> instead,
and iterate through the <code>argv</code> arguments itself. The <i>recurse</i>
parameter should almost always be <code>FALSE</code>.  Exceptions to this rule
are very rare.<br>
<br>
Returns <code>-1</code> if the parameter <i>name</i> is not found.  Note that
parameters are not allowed to contain negative integers.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#get_param_int">src/dirtree.c</a><br>

<hr>
<a name="get_param_int_next"><b>get_param_int_next</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  long get_param_int_next(const char *<i>name</i>, int <i>recurse</i>)
</pre>
<font color=blue>Comments</font>:  Similar to
<a href="#get_param_int"><code>get_param_int()</code></a>, this function will
retrieve the next matching parameter after a call to
<code>get_param_int()</code>.<br>
<br>
Returns <code>-1</code> if the parameter <i>name</i> is not found, or if this
function was not preceded by a call to <code>get_param_int()</code>.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#get_param_int_next">src/dirtree.c</a><br>

<hr>
<a name="get_param_ptr"><b>get_param_ptr</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void *get_param_ptr(xaset_t *<i>set</i>, const char *<i>name</i>, int <i>recurse</i>)
</pre>
<font color=blue>Comments</font>:  This function returns the first argument
in a <a href="macros.html#CONF_PARAM"><code>CONF_PARAM</code></a> configuration
record.  If more than one, or all, arguments are needed, the caller will
need to use <a href="#find_config"><code>find_config()</code></a> instead,
and iterate through the <code>argv</code> arguments itself.  The <i>recurse</i>
parameter should almost always be <code>FALSE</code>.  Exceptions to this rule
are very rare.<br>
<br>
Returns <code>NULL</code> if the parameter <i>name</i> is not found.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#get_param_ptr">src/dirtree.c</a><br>

<hr>
<a name="get_param_ptr_next"><b>get_param_ptr_next</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void *get_param_ptr_next(const char *<i>name</i>, int <i>recurse</i>)
</pre>
<font color=blue>Comments</font>:  Similar to
<a href="#get_param_ptr"><code>get_param_ptr()</code></a>, this function will
retrieve the next matching parameter after a call to
<code>get_param_ptr()</code>.<br>
<br>
Returns <code>NULL</code> if the parameter <i>name</i> is not found, or if this
function was not preceded by a call to <code>get_param_ptr()</code>.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#get_param_ptr_next">src/dirtree.c</a><br>

<hr>
<a name="get_token"><b>get_token</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  char *get_token(char **<i>s</i>, char *<i>sep</i>)
</pre>
<font color=blue>Comments</font>:  This function tokenizes the string <i>s</i>,
incrementing the pointer to <i>s</i> to the next non-separator <i>sep</i>
in the string, and returning a token.  If the source string <i>s</i> is empty
or <code>NULL</code>, the next token returned will be <code>NULL</code>.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/support.c.html#get_token">src/support.c</a><br>

<hr>
<a name="get_word"><b>get_word</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  char *get_word(char **<i>cp</i>)
</pre>
<font color=blue>Comments</font>: Retrieve an individual word, space-delimited,
from the given string <i>cp</i>, respecting quotes and escapes.  The <i>cp</i>
pointer is advanced as the word is consumed from the string.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#get_word">src/dirtree.c</a><br>

<hr>
<a name="group_expression"><b>group_expression</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int group_expression(char **<i>expr</i>)
</pre>
<font color=blue>Comments</font>:  Evaluates the given expression <i>expr</i>
as a group <code>AND</code> expression, which means that <i>all</i> group
memberships must be valid for the expression to be true.  Returns
<code>TRUE</code> if the current connected user matches the group expression,
<code>FALSE</code> otherwise.<br>
<br>
<font color=blue>Bugs</font>: This function assumes use of
<code>session.groups</code>.  Better would be to evaluate <i>expr</i> against
a caller-provided array of group names.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#group_expression">src/dirtree.c</a><br>

<hr>
<a name="handle_alarm"><b>handle_alarm</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void handle_alarm(void)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/timers.c.html#handle_alarm">src/timers.c</a><br>

<hr>
<a name="ident_timeout_cb"><b>ident_timeout_cb</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int ident_timeout_cb(CALLBACK_FRAME)
</pre>
<font color=blue>Comments</font>: Timer callback function which aborts an
ident (RFC 1413) lookup.  The timer length is set to 10 seconds, and is
tunable via the <code>PR_TUNABLE_TIMEOUTIDENT</code> macro, defined in
<a href="../src/include/options.h.html#PR_TUNABLE_TIMEOUTIDENT">include/options.h</a>.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/ident.c.html#ident_timeout_cb">src/ident.c</a><br>

<hr>
<a name="idle_timeout_cb"><b>idle_timeout_cb</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int idle_timeout_cb(CALLBACK_FRAME)
</pre>
<font color=blue>Comments</font>:  Timer callback function which disconnects
an idle session.  The timer length is configurable via the
<code>TimeoutIdle</code> configuration directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/main.c.html#idle_timeout_cb">src/main.c</a><br>

<hr>
<a name="inet_accept"><b>inet_accept</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  conn_t *inet_accept(pool *<i>pool</i>, conn_t *<i>d</i>, conn_t *<i>c</i>, int <i>rfd</i>, int <i>wfd</i>, int <i>resolve</i>)
</pre>
<font color=blue>Comments</font>: Accepts a new connection, cloning the
existing <code>conn_t</code> and returning it, or <code>NULL</code> upon
error.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/inet.c.html#inet_accept">src/inet.c</a><br>

<hr>
<a name="inet_accept_nowait"><b>inet_accept_nowait</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int inet_accept_nowait(pool *<i>pool</i>, conn_t *<i>c</i>)
</pre>
<font color=blue>Comments</font>: Accepts a new connection, return immediately
with <code>-1</code> if no connection is available.  If a connection is
accepted, creating a new <code>conn_t</code> and potential resolving is
deferred, and a normal socket <code>fd</code> is returned for the new
connection, which can later be used in <code>inet_openrw</code> to fully open
and resolve addresses.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/inet.c.html#inet_accept_nowait">src/inet.c</a><br>

<hr>
<a name="inet_ascii"><b>inet_ascii</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  char *inet_ascii(pool *<i>pool</i>, p_in_addr_t *<i>addr</i>)
</pre>
<font color=blue>Comments</font>: Wrapper function for <code>inet_ntoa</code>,
except it stores the result in memory allocated from <i>pool</i>.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/inet.c.html#inet_ascii">src/inet.c</a><br>

<hr>
<a name="inet_associate"><b>inet_associate</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  conn_t *inet_associate(pool *<i>pool</i>, conn_t *<i>c</i>, p_in_addr_t *<i>addr</i>, IOFILE *<i>inf</i>,
    IOFILE *<i>outf</i>, int <i>resolve</i>)
</pre>
<font color=blue>Comments</font>: Associate the already open streams with
a connection, returning <code>NULL</code> if either stream points to a
non-socket descriptor.  If <code>addr</code> is non-<code>NULL</code>,
remote address discovery is attempted.  If <code>resolve</code> is non-zero,
the remote address is reverse solved.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/inet.c.html#inet_associate">src/inet.c</a><br>

<hr>
<a name="inet_close"><b>inet_close</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void inet_close(pool *<i>pool</i>, conn_t *<i>c</i>)
</pre>
<font color=blue>Comments</font>:  With this function, it is not necessary
to close file descriptors or schedule <code>IOFILE</code>s for removal
because the creator of the connection, either <a href="#inet_create_connection"><code>inet_create_connection()</code></a> or <a href="#inet_copy_connection"><code>inet_copy_connection()</code></a> will have registered a <code>pool</code>
cleanup handler (<a href="#conn_cleanup_cb"><code>conn_cleanup_cb()</code></a>)
which will do all of this work for us.  Simply destroy the connection <i>c</i>'s
<code>pool</code>, and it will do the rest.  The given <i>pool</i> is not used
by this function.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/inet.c.html#inet_close">src/inet.c</a><br>

<hr>
<a name="inet_connect"><b>inet_connect</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int inet_connect(pool *<i>pool</i>, conn_t *<i>c</i>, p_in_addr_t *<i>addr</i>, int <i>port</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/inet.c.html#inet_connect">src/inet.c</a><br>

<hr>
<a name="inet_connect_nowait"><b>inet_connect_nowait</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int inet_connect_nowait(pool *<i>pool</i>, conn_t *<i>c</i>, p_in_addr_t *<i>addr</i>, int <i>port</i>)
</pre>
<font color=blue>Comments</font>: Attempt to connect a connection, returning
immediately with <code>1</code> if connected, <code>0</code> if not
connected, or <code>-1</code> if error.  This only needs to be called once,
and can then be selected for writing.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/inet.c.html#inet_connect_nowait">src/inet.c</a><br>

<hr>
<a name="inet_copy_connection"><b>inet_copy_connection</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  conn_t *inet_copy_connection(pool *<i>p</i>, conn_t *<i>c</i>)
</pre>
<font color=blue>Comments</font>: Copy a connection structure, also
creating a subpool for the new connection.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/inet.c.html#inet_copy_connection">src/inet.c</a><br>

<hr>
<a name="inet_create_connection"><b>inet_create_connection</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  conn_t *inet_create_connection(pool *<i>p</i>, xaset_t *<i>servers</i>, int <i>fd</i>, p_in_addr_t *<i>bind_addr</i>,
    int <i>port</i>, int <i>retry_bind</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/inet.c.html#inet_create_connection">src/inet.c</a><br>

<hr>
<a name="inet_create_connection_portrange"><b>inet_create_connection_portrange</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  conn_t *inet_create_connection_portrange(pool *<i>p</i>, xaset_t *<i>servers</i>, p_in_addr_t *<i>bind_addr</i>,
    int <i>low_port</i>, int <i>high_port</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/inet.c.html#inet_create_connection_portrange">src/inet.c</a><br>

<hr>
<a name="inet_fqdn"><b>inet_fqdn</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  char *inet_fqdn(pool *<i>pool</i>, const char *<i>addr</i>)
</pre>
<font color=blue>Comments</font>: Returns the FQDN (<b>F</b>ully
<b>Q</b>ualified <b>D</b>omain <b>N</b>ame) of an address.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/inet.c.html#inet_fqdn">src/inet.c</a><br>

<hr>
<a name="inet_get_conn_info"><b>inet_get_conn_info</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int inet_get_conn_info(conn_t *<i>c</i>, int <i>fd</i>)
</pre>
<font color=blue>Comments</font>:  Using the socket descriptor <i>fd</i>,
retrieve the local and remote IP addresses and ports in use, and store them
in <i>c</i>'s fields.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/inet.c.html#inet_get_conn_info">src/inet.c</a><br>

<hr>
<a name="inet_getaddr"><b>inet_getaddr</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  p_in_addr_t *inet_getaddr(pool *<i>pool</i>, char *<i>name</i>)
</pre>
<font color=blue>Comments</font>: DNS/hosts lookup for a particular <i>name</i>.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/inet.c.html#inet_getaddr">src/inet.c</a><br>

<hr>
<a name="inet_gethostname"><b>inet_gethostname</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
   char *inet_gethostname(pool *<i>pool</i>)
</pre>
<font color=blue>Comments</font>: Return the hostname (wrapper for
<code>gethostname(2)</code>, except that it returns the FQDN).<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/inet.c.html#inet_gethostname">src/inet.c</a><br>

<hr>
<a name="inet_getname"><b>inet_getname</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  char *inet_getname(pool *<i>pool</i>, p_in_addr_t *<i>addr</i>)
</pre>
<font color=blue>Comments</font>: Given an IP address, return the FQDN.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/inet.c.html#inet_getname">src/inet.c</a><br>

<hr>
<a name="inet_getservport"><b>inet_getservport</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int inet_getservport(pool *<i>pool</i>, char *<i>serv</i>, char *<i>proto</i>)
</pre>
<font color=blue>Comments</font>: Find a service, and return its port number
(in network byte order).<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/inet.c.html#inet_getservport">src/inet.c</a><br>

<hr>
<a name="inet_initialize_connection"><b>inet_initialize_connection</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static conn_t *inet_initialize_connection(pool *<i>p</i>, xaset_t *<i>servers</i>, int <i>fd</i>, p_in_addr_t *<i>bind_addr</i>,
    int <i>port</i>, int <i>retry_bind</i>, int <i>reporting</i>)
</pre>
<font color=blue>Comments</font>: Initialize a new connection record,
also creating a new subpool just for the new connection.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/inet.c.html#inet_initialize_connection">src/inet.c</a><br>

<hr>
<a name="inet_listen"><b>inet_listen</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int inet_listen(pool *<i>pool</i>, conn_t *<i>c</i>, int <i>backlog</i>)
</pre>
<font color=blue>Comments</font>: Puts a connection in listening mode.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/inet.c.html#inet_listen">src/inet.c</a><br>

<hr>
<a name="inet_openrw"><b>inet_openrw</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  conn_t *inet_openrw(pool *<i>pool</i>, conn_t *<i>c</i>, p_in_addr_t *<i>addr</i>, int <i>fd</i>, int <i>rfd</i>,
    int <i>wfd</i>, int <i>resolve</i>)
</pre>
<font color=blue>Comments</font>: Open streams for a new socket; if
<i>rfd</i> and <code><i>wfd</i> != -1</code>, two new <code>fd</code>s are
<code>dup()</code>ed to the respective read/write <code>fd</code>s.  If the
<code>fd</code>s specified correspond to the normal <code>stdin</code> and
<code>stdout</code>, the streams opened will be assigned to <code>stdin</code>
and <code>stdout</code> in an intuitive fashion (so that they may be later used
by <code>printf()</code>/<code>fgets()</code> type <code>libc</code> functions).
If <i>addr</i> is non-<code>NULL</code>, the address is assigned
to the connection (as the <i>source</i> of the connection).  If it is
<code>NULL</code>, remote address discovery will be attempted.  The
connection structure's appropriate fields are filled in, including the
<i>destination</i> address.  Finally, if <i>resolve</i> is non-zero,
<code>inet_openrw()</code> will attempt to reverse resolve the remote
address.  A new connection structure is created from <i>pool</i>.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/inet.c.html#inet_openrw">src/inet.c</a><br>

<hr>
<a name="inet_pool_cleanup_cb"><b>_inet_pool_cleanup</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static void inet_pool_cleanup_cb(void *<i>ignore</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/inet.c.html#inet_pool_cleanup_cb">src/inet.c</a><br>

<hr>
<a name="inet_resetlisten"><b>inet_resetlisten</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int inet_resetlisten(pool *<i>pool</i>, conn_t *<i>c</i>)
</pre>
<font color=blue>Comments</font>: Reset a connection back to listening mode.
Enables blocking mode for safety.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/inet.c.html#inet_resetlisten">src/inet.c</a><br>

<hr>
<a name="inet_resolve_ip"><b>inet_resolve_ip</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void inet_resolve_ip(pool *<i>pool</i>, conn_t *<i>c</i>)
</pre>
<font color=blue>Comments</font>: Performs reverse IP resolution via DNS on
an existing connection.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/inet.c.html#inet_resolve_ip">src/inet.c</a><br>

<hr>
<a name="inet_reverse_dns"><b>inet_reverse_dns</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int inet_reverse_dns(pool *<i>pool</i>, int <i>enable</i>)
</pre>
<font color=blue>Comments</font>: Enable or disable reverse DNS lookups.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/inet.c.html#inet_reverse_dns">src/inet.c</a><br>

<hr>
<a name="inet_set_proto_options"><b>inet_set_proto_options</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int inet_set_proto_options(pool *<i>pool</i>, conn_t *<i>c</i>, int <i>nodelay</i>, int <i>lowdelay</i>, int <i>throughput</i>,
    int <i>nopush</i>)
</pre>
<font color=blue>Comments</font>:  Sets the following protocol-level options
(if supported by the OS) on the given connection <i>c</i>:
<code>TCP_NODELAY</code>, <code>IP_TOS</code> (for <i>low delay</i> and
<i>throughput</i> options), and <code>TCP_NOPUSH</code>.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/inet.c.html#inet_set_proto_options">src/inet.c</a><br>

<hr>
<a name="inet_setasync"><b>inet_setasync</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int inet_setasync(pool *<i>pool</i>, conn_t *<i>c</i>)
</pre>
<font color=blue>Comments</font>: Puts a socket in asynchronous mode, so
that <code>SIGURG</code> is raised on OOB data.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/inet.c.html#inet_setasync">src/inet.c</a><br>

<hr>
<a name="inet_setblock"><b>inet_setblock</b><br>
<br>
<font color=blue>Comments</font>: Puts a socket in blocking mode.<br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int inet_setblock(pool *<i>pool</i>, conn_t *<i>c</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/inet.c.html#inet_setblock">src/inet.c</a><br>

<hr>
<a name="inet_setnonblock"><b>inet_setnonblock</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int inet_setnonblock(pool *<i>pool</i>, conn_t *<i>c</i>)
</pre>
<font color=blue>Comments</font>: Puts a socket in non-blocking mode.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/inet.c.html#inet_setnonblock">src/inet.c</a><br>

<hr>
<a name="inet_setoptions"><b>inet_setoptions</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int inet_setoptions(pool *<i>pool</i>, conn_t *<i>c</i>, int <i>rcvbuf</i>, int <i>sndbuf</i>)
</pre>
<font color=blue>Comments</font>: Set socket-level options on a connection.  If
file descriptor sets of <i>c</i> are <code>-1</code>, the socket
<code>snd</code>/<code>rcv</code> buffers will be set according to the
server configuration.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/inet.c.html#inet_setoptions">src/inet.c</a><br>

<hr>
<a name="inet_validate"><b>inet_validate</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  char *inet_validate(char *<i>buf</i>)
</pre>
<font color=blue>Comments</font>: Validate anything returned from the
<i>outside</i>, since it's untrusted information.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/utils.c.html#inet_validate">src/utils.c</a><br>

<hr>
<a name="inetd_main"><b>inetd_main</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static void inetd_main(void)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/main.c.html#inetd_main">src/main.c</a><br>

<hr>
<a name="init_child_modules"><b>init_child_modules</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int init_child_modules(void)
</pre>
<font color=blue>Comments</font>:  Called after forking in order to inform
and initialize any modules that need to know that a child connection has
been spawned.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/modules.c.html#init_child_modules">src/modules.c</a><br>

<hr>
<a name="init_conf_stacks"><b>init_conf_stacks</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void init_conf_stacks(void)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#init_conf_stacks">src/dirtree.c</a><br>

<hr>
<a name="init_config"><b>init_config</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void init_config(void)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#init_config">src/dirtree.c</a><br>

<hr>
<a name="init_dyn_stacks"><b>init_dyn_stacks</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void init_dyn_stacks(pool *<i>p</i>, config_rec *<i>top</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#init_dyn_stacks">src/dirtree.c</a><br>

<hr>
<a name="init_fs"><b>init_fs</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int init_fs(void)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#init_fs">src/fs.c</a><br>

<hr>
<a name="init_inet"><b>init_inet</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void init_inet(void)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/inet.c.html#init_inet">src/inet.c</a><br>

<hr>
<a name="init_log"><b>init_log</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void init_log(void)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/log.c.html#init_log">src/log.c</a><br>

<hr>
<a name="init_modules"><b>init_modules</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int init_modules(void)
</pre>
<font color=blue>Comments</font>: Called only during server startup, before the
configuration file is parsed, in order to allow all registered modules time
to initialize and prepare themselves for file parsing and session handling.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/modules.c.html#init_modules">src/modules.c</a><br>

<hr>
<a name="init_set_proc_title"><b>init_set_proc_title</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static void init_set_proc_title(int <i>argc</i>, char *<i>argv</i>[], char *<i>envp</i>[])
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/main.c.html#init_set_proc_title">src/main.c</a><br>

<hr>
<a name="install_signal_handlers"><b>install_signal_handlers</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static void install_signal_handlers(void)
</pre>
<font color=blue>Comments</font>: The subpool for the child list is created
the first time the server forks off a child.  To conserve memory, the pool and
list are destroyed when the last child dies, to prevent the list from eating
more and more memory on long uptimes.<br>
<br> 
<font color=blue>Source File</font>:
  <a href="../src/src/main.c.html#install_signal_handlers">src/main.c</a><br>

<hr>
<a name="is_dotdir"><b>is_dotdir</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int is_dotdir(char *<i>s</i>)
</pre>
<font color=blue>Comments</font>: Returns <code>TRUE</code> if the given path
<code>s</code> is <code>&quot;.&quot;</code>, <code>&quot;./&quot;</code>,
<code>&quot;../&quot;</code>, or <code>&quot;..&quot;</code>, <code>FALSE</code>
otherwise.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_ls.c.html#is_dotdir">modules/mod_ls.c</a><br>

<hr>
<a name="isnumeric"><b>isnumeric</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int isnumeric(char *<i>str</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/ftpshut.c.html#isnumeric">src/ftpshut.c</a><br>

<hr>
<a name="kludge_disable_umask"><b>kludge_disable_umask</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void kludge_disable_umask(void)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#kludge_disable_umask">src/dirtree.c</a><br>

<hr>
<a name="kludge_enable_umask"><b>kludge_enable_umask</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void kludge_enable_umask(void)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#kludge_enable_umask">src/dirtree.c</a><br>

<hr>
<a name="list_modules"><b>list_modules</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void list_modules(void)
</pre>
<font color=blue>Comments</font>:  This function simply prints out the
list of modules compiled into the server at configure-time.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/modules.c.html#list_modules">src/modules.c</a><br>

<hr>
<a name="listdir"><b>listdir</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int listdir(cmd_rec *<i>cmd</i>, pool *<i>workp</i>, const char *<i>name</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_ls.c.html#listdir">modules/mod_ls.c</a><br>

<hr>
<a name="listen_binding"><b>listen_binding</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int listen_binding(fd_set *<i>rfd</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/main.c.html#listen_binding">src/main.c</a><br>

<hr>
<a name="listfile"><b>listfile</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int listfile(cmd_rec *<i>cmd</i>, pool *<i>p</i>, const char *<i>name</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_ls.c.html#listfile">modules/mod_ls.c</a><br>

<hr>
<a name="lockdown"><b>lockdown</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int lockdown(char *<i>newroot</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_auth.c.html#lockdown">modules/mod_auth.c</a><br>

<hr>
<a name="log"><b>log</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void log(int <i>priority</i>, int <i>f</i>, char *<i>s</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/log.c.html#log">src/log.c</a><br>

<hr>
<a name="log_auth"><b>log_auth</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void log_auth(int <i>priority</i>, char *<i>fmt</i>, ...)
</pre>
<font color=blue>Comments</font>:  This function works much like
<a href="#log_pri"><code>log_pri()</code></a>, except that the log entry is
sent to the <code>LOG_AUTHPRIV</code> facility, presumably because the
log entry does not need to be seen by everyone.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/log.c.html#log_auth">src/log.c</a><br>

<hr>
<a name="log_auth_complete"><b>log_auth_complete</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET log_auth_complete(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_log.c.html#log_auth_complete">modules/mod_log.c</a><br>

<hr>
<a name="log_close_xfer"><b>log_close_xfer</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void log_close_xfer(void)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/log.c.html#log_close_xfer">src/log.c</a><br>

<hr>
<a name="log_closesyslog"><b>log_closesyslog</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void log_closesyslog(void)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/log.c.html#log_closesyslog">src/log.c</a><br>

<hr>
<a name="log_command"><b>log_command</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET log_command(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_log.c.html#log_command">modules/mod_log.c</a><br>

<hr>
<a name="log_debug"><b>log_debug</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void log_debug(int <i>level</i>, char *<i>str</i>, ...)
</pre>
<font color=blue>Comments</font>: This function formats the given parameters
using <code>vnsnprintf()</code> according to the given format <i>str</i>, then
sends the message to <a href="#log"><code>log()</code></a> to be logged at
the given debug <i>level</i>.  <i>level</i> should be one the
<code>DEBUG</code><i>n</i> defines in
<a href="../src/include/log.h.html">include/log.h</a>.  If <i>level</i> is
greater than the current debug level, the message is silently ignored.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/log.c.html#log_debug">src/log.c</a><br>

<hr>
<a name="log_discard"><b>log_discard</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void log_discard(void)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/log.c.html#log_discard">src/log.c</a><br>

<hr>
<a name="log_init"><b>log_init</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int log_init(void)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_log.c.html#log_init">modules/mod_log.c</a><br>

<hr>
<a name="log_open_xfer"><b>log_open_xfer</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int log_open_xfer(const char *<i>fn</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/log.c.html#log_open_xfer">src/log.c</a><br>

<hr>
<a name="log_openfile"><b>log_openfile</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int log_openfile(const char *<i>log_file</i>, int *<i>log_fd</i>, mode_t <i>log_mode</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/log.c.html#log_openfile">src/log.c</a><br>

<hr>
<a name="log_opensyslog"><b>log_opensyslog</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int log_opensyslog(const char *<i>fn</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/log.c.html#log_opensyslog">src/log.c</a><br>

<hr>
<a name="log_pri"><b>log_pri</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void log_pri(int <i>priority</i>, char *<i>fmt</i>, ...)
</pre>
<font color=blue>Comments</font>: This function formats the given parameters
using <code>vnsnprintf()</code> according to the given <i>fmt</i>, then
sends the message to <a href="#log"><code>log()</code></a> to be logged at
the given <i>priority</i>.  <i>priority</i> should be one the
<code>PR_LOG_*</code> log priorities defined in
<a href="../src/include/log.h.html">include/log.h</a>.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/log.c.html#log_pri">src/log.c</a><br>

<hr>
<a name="log_rehash"><b>log_rehash</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void log_rehash(void *<i>d</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_log.c.html#log_rehash">modules/mod_log.c</a><br>

<hr>
<a name="log_sess_init"><b>log_sess_init</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int log_sess_init(void)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_log.c.html#log_sess_init">modules/mod_log.c</a><br>

<hr>
<a name="log_setdebuglevel"><b>log_setdebuglevel</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int log_setdebuglevel(int <i>level</i>)
</pre>
<font color=blue>Comments</font>:  This sets the debugging log level, as per
the <code>DEBUG</code><i>n</i> defines in
<a href="../src/include/log.h.html">include/log.h</a>.  The new debug level
is set, and the previous debug level is returned.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/log.c.html#log_setdebuglevel">src/log.c</a><br>

<hr>
<a name="log_setfacility"><b>log_setfacility</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void log_setfacility(int <i>facility</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/log.c.html#log_setfacility">src/log.c</a><br>

<hr>
<a name="log_stderr"><b>log_stderr</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void log_stderr(int <i>bool</i>)
</pre>
<font color=blue>Comments</font>:  This function disables logging to
<b>stderr</b>, based on the given <i>bool</i> parameter, and should be called
right before <code>fork()</code>ing or dissociation from the controllling
terminal.  After disabling <b>stderr</b>, all messages will be sent to
<code>syslog</code>.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/log.c.html#log_stderr">src/log.c</a><br>

<hr>
<a name="log_wtmp"><b>log_wtmp</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int log_wtmp(char *<i>line</i>, char *<i>name</i>, char *<i>host</i>, p_in_addr_t *<i>ip</i>)
</pre>
<font color=blue>Comments</font>: This functions logs an entry to
<code>wtmp/wtmpx</code>, and <b>must</b> be called as root <b>before</b> a
<code>chroot()</code> occurs.<br>
<br>
<font color=blue>Notes</font>: This function has some portability
<code>#ifdef</code>s in it which <i>should</i> work, but haven't really been
tested.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/log.c.html#log_wtmp">src/log.c</a><br>

<hr>
<a name="log_xfer"><b>log_xfer</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int log_xfer(int <i>xfertime</i>, char *<i>remhost</i>, unsigned long <i>fsize</i>, char *<i>fname</i>, char <i>xfertype</i>,
    char <i>direction</i>, char <i>access</i>, char *<i>user</i>, char <i>abort_flag</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/log.c.html#log_xfer">src/log.c</a><br>

<hr>
<a name="logformat"><b>logformat</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void logformat(char *<i>nickname</i>, char *<i>fmts</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_log.c.html#logformat">modules/mod_log.c</a><br>

<hr>
<a name="login_check_limits"><b>login_check_limits</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int login_check_limits(xaset_t *<i>conf</i>, int <i>recurse</i>, int <i>and</i>, int *<i>found</i>)
</pre>
<font color=blue>Comments</font>:<br>
<br>
<font color=blue>Notes</font>: If <code><i>and</i> == 1</code>, the log is
short-circuited so that the first failure results in a <code>FALSE</code>
return value from the entire function; if <code><i>and</i> == 0</code>, an
<code>OR</code>ing operation is assumed, and the function will return
<code>TRUE</code> if any <code>&lt;Limit LOGIN&gt;</code> allows access.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#login_check_limits">src/dirtree.c</a><br>

<hr>
<a name="ls_done"><b>ls_done</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void ls_done(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_ls.c.html#ls_done">modules/mod_ls.c</a><br>

<hr>
<a name="ls_err_nlst"><b>ls_err_nlst</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET ls_err_nlst(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_ls.c.html#ls_err_nlst">modules/mod_ls.c</a><br>

<hr>
<a name="ls_list"><b>ls_list</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET ls_list(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Command handler for the <code>LIST</code>
FTP command.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_ls.c.html#ls_list">modules/mod_ls.c</a><br>

<hr>
<a name="ls_log_nlst"><b>ls_log_nlst</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET ls_log_nlst(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_ls.c.html#ls_log_nlst">modules/mod_ls.c</a><br>

<hr>
<a name="ls_nlst"><b>ls_nlst</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
 MODRET ls_nlst(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Command handler for the <code>NLST</code>
FTP command.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_ls.c.html#ls_nlst">modules/mod_ls.c</a><br>

<hr>
<a name="ls_perms"><b>ls_perms</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int ls_perms(pool *<i>p</i>, cmd_rec *<i>cmd</i>, const char *<i>path</i>, int *<i>hidden</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_ls.c.html#ls_perms">modules/mod_ls.c</a><br>

<hr>
<a name="ls_perms_full"><b>ls_perms_full</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int ls_perms_full(pool *<i>p</i>, cmd_rec *<i>cmd</i>, const char *<i>path</i>, int *<i>hidden</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_ls.c.html#ls_perms_full">modules/mod_ls.c</a><br>

<hr>
<a name="ls_post_pass"><b>ls_post_pass</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET ls_post_pass(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_ls.c.html#ls_post_pass">modules/mod_ls.c</a><br>

<hr>
<a name="ls_stat"><b>ls_stat</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET ls_stat(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Command handler for the <code>STAT</code>
FTP command.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_ls.c.html#ls_stat">modules/mod_ls.c</a><br>

<hr>
<a name="ls_terminate"><b>ls_terminate</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void ls_terminate(void)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_ls.c.html#ls_terminate">modules/mod_ls.c</a><br>

<hr>
<a name="main_exit"><b>main_exit</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void main_exit(void *<i>pv</i>, void *<i>lv</i>, void *<i>ev</i>, void *<i>dummy</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/main.c.html#main_exit">src/main.c</a><br>

<hr>
<a name="main_set_idle"><b>main_set_idle</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void main_set_idle(void)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/main.c.html#main_set_idle">src/main.c</a><br>

<hr>
<a name="make_arg_str"><b>make_arg_str</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  char *make_arg_str(pool *<i>p</i>, int <i>argc</i>, char **<i>argv</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/support.c.html#make_arg_str">src/support.c</a><br>

<hr>
<a name="make_array"><b>make_array</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  array_header *make_array(pool *<i>p</i>, int <i>nelts</i>, int <i>elt_size</i>)
</pre>
<font color=blue>Comments</font>:  This function allocates an
<a href="typedefs.html#array_header"><code>array_header</code></a> from the
given <code>pool</code> <i>p</i>, initializing it to have <i>nelts</i>
number of elements, each of <i>elt_size</i> size.  If <i>nelts</i> is less than
<code>1</code>, it will automatically be set to <code>1</code>, so that
the <code>array_header</code> has at least one allocated slot.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/pool.c.html#make_array">src/pool.c</a><br>

<hr>
<a name="make_ftp_cmd"><b>make_ftp_cmd</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static cmd_rec *make_ftp_cmd(pool *<i>p</i>, char *<i>buf</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/main.c.html#make_ftp_cmd">src/main.c</a><br>

<hr>
<a name="make_sub_pool"><b>make_sub_pool</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  struct pool *make_sub_pool(struct pool *<i>p</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/pool.c.html#make_sub_pool">src/pool.c</a><br>

<hr>
<a name="malloc_block"><b>malloc_block</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  union block_hdr *malloc_block(int <i>size</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/pool.c.html#malloc_block">src/pool.c</a><br>

<hr>
<a name="mask_signals"><b>mask_signals</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static void mask_signals(unsigned char <i>block</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/support.c.html#mask_signals">src/support.c</a><br>

<hr>
<a name="match_ip"><b>match_ip</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int match_ip(p_in_addr_t *<i>addr</i>, char *<i>name</i>, const char *<i>match</i>)
</pre>
<font color=blue>Comments</font>:  Returns <code>1</code> if it is an
explicit match; <code>-1</code> if it is an explicit mismatch (<i>i.e.</i>
&quot;NONE&quot;); <code>0</code> if there is no match.<br>
<br>
<font color=blue>Notes</font>: this explanation is incomplete.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#match_ip">src/dirtree.c</a><br>

<hr>
<a name="modpam_exit"><b>modpam_exit</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static void modpam_exit(void)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_pam.c.html#modpam_exit">modules/mod_pam.c</a><br>

<hr>
<a name="mod_create_data"><b>mod_create_data</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  modret_t *mod_create_data(cmd_rec *<i>cmd</i>, void *<i>d</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/modules.c.html#mod_create_data">src/modules.c</a><br>

<hr>
<a name="mod_create_error"><b>mod_create_error</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  modret_t *mod_create_error(cmd_rec *<i>cmd</i>, int <i>mr_errno</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/modules.c.html#mod_create_error">src/modules.c</a><br>

<hr>
<a name="mod_create_ret"><b>mod_create_ret</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  modret_t *mod_create_ret(cmd_rec *<i>cmd</i., unsigned char <i>err</i>, char *<i>n</i>, char *<i>m</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/modules.c.html#mod_create_ret">src/modules.c</a><br>

<hr>
<a name="mod_find_auth_symbol"><b>mod_find_auth_symbol</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  authtable *mod_find_auth_symbol(char *<i>name</i>, int *<i>idx_cache</i>, authtable *<i>last</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/modules.c.html#mod_find_auth_symbol">src/modules.c</a><br>

<hr>
<a name="mod_find_cmd_symbol"><b>mod_find_cmd_symbol</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  cmdtable *mod_find_cmd_symbol(char *<i>name</i>, int *<i>idx_cache</i>, cmdtable *<i>last</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/modules.c.html#mod_find_cmd_symbol">src/modules.c</a><br>

<hr>
<a name="mod_find_conf_symbol"><b>mod_find_conf_symbol</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  conftable *mod_find_conf_symbol(char *<i>name</i>, int *<i>idx_cache</i>, conftable *<i>last</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/modules.c.html#mod_find_conf_symbol">src/modules.c</a><br>

<hr>
<a name="mod_privdata_alloc"><b>mod_privdata_alloc</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  privdata_t *mod_privdata_alloc(cmd_rec *<i>cmd</i>, char *<i>tag</i>, int <i>size</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/modules.c.html#mod_privdata_alloc">src/modules.c</a><br>

<hr>
<a name="mod_privdata_find"><b>mod_privdata_find</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  privdata_t *mod_privdata_find(cmd_rec *<i>cmd</i>, char *<i>tag</i>, module *<i>m</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/modules.c.html#mod_privdata_find">src/modules.c</a><br>

<hr>
<a name="module_exists"><b>module_exists</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int module_exists(const char *<i>name</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/modules.c.html#module_exists">src/modules.c</a><br>

<hr>
<a name="netio_buffer_alloc"><b>netio_buffer_alloc</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static pr_netio_buffer_t *netio_buffer_alloc(pr_netio_stream_t *<i>nstrm</i>)
</pre>
<font color=blue>Comments</font>:  Create a new <code>pr_netio_buffer_t</code>
from <i>nstrm</i>'s <code>pool</code>, and assign it to <i>nstrm</i>.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/netio.c.html#netio_buffer_alloc">src/netio.c</a><br>

<hr>
<a name="new_block"><b>new_block</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  union block_hdr *new_block(int <i>min_size</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/pool.c.html#new_block">src/pool.c</a><br>

<hr>
<a name="nlstdir"><b>nlstdir</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int nlstdir(cmd_rec *<i>cmd</i>, const char *<i>dir</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_ls.c.html#nlstdir">modules/mod_ls.c</a><br>

<hr>
<a name="nlstfile"><b>nlstfile</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int nlstfile(cmd_rec *<i>cmd</i>, const char *<i>file</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_ls.c.html#nlstfile">modules/mod_ls.c</a><br>

<hr>
<a name="noxfer_timeout_cb"><b>noxfer_timeout_cb</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int noxfer_timeout_cb(CALLBACK_FRAME)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_xfer.c.html#noxfer_timeout_cb">modules/mod_xfer.c</a><br> 

<hr>
<a name="null_alloc"><b>null_alloc</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static void *null_alloc(size_t <i>size</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/pool.c.html#null_alloc">src/pool.c</a><br>

<hr>
<a name="outputfiles"><b>outputfiles</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int outputfiles(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_ls.c.html#outputfiles">modules/mod_ls.c</a><br>

<hr>
<a name="p_endgrent"><b>p_endgrent</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static void p_endgrent(void)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_unixpw.c.html#p_endgrent">modules/mod_unixpw.c</a><br>

<hr>
<a name="p_endpwent"><b>p_endpwent</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static void p_endpwent(void)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_unixpw.c.html#p_endpwent">modules/mod_unixpw.c</a><br>

<hr>
<a name="p_getgrent"><b>p_getgrent</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static struct group *p_getgrent(void)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_unixpw.c.html#p_getgrent">modules/mod_unixpw.c</a><br>

<hr>
<a name="p_getgrgid"><b>p_getgrgid</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static struct group *p_getgrgid(gid_t <i>gid</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_unixpw.c.html#p_getgrgid">modules/mod_unixpw.c</a><br>

<hr>
<a name="p_getgrnam"><b>p_getgrnam</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static struct group *p_getgrnam(const char *<i>name</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_unixpw.c.html#p_getgrnam">modules/mod_unixpw.c</a><br>

<hr>
<a name="p_getpwent"><b>p_getpwent</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static struct passwd *p_getpwent(void)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_unixpw.c.html#p_getpwent">modules/mod_unixpw.c</a><br>

<hr>
<a name="p_getpwnam"><b>p_getpwnam</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static struct passwd *p_getpwnam(const char *<i>name</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_unixpw.c.html#p_getpwnam">modules/mod_unixpw.c</a><br>

<hr>
<a name="p_getpwuid"><b>p_getpwuid</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static struct passwd *p_getpwuid(uid_t <i>uid</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_unixpw.c.html#p_getpwuid">modules/mod_unixpw.c</a><br>

<hr>
<a name="p_setgrent"><b>p_setgrent</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static void p_setgrent(void)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_unixpw.c.html#p_setgrent">modules/mod_unixpw.c</a><br>

<hr>
<a name="p_setpwent"><b>p_setpwent</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static void p_setpwent(void)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_unixpw.c.html#p_setpwent">modules/mod_unixpw.c</a><br>

<hr>
<a name="palloc"><b>palloc</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void *palloc(struct pool *<i>p</i>, int <i>reqsize</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/pool.c.html#palloc">src/pool.c</a><br>

<hr>
<a name="pam_auth"><b>pam_auth</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET pam_auth(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_pam.c.html#pam_auth">modules/mod_pam.c</a><br>

<hr>
<a name="pam_exchange"><b>pam_exchange</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int pam_exchange(int <i>num_msg</i>, struct pam_message **<i>msg</i>, struct pam_response **<i>resp</i>,
    void *<i>appdata_ptr</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_pam.c.html#pam_exchange">modules/mod_pam.c</a><br>

<hr>
<a name="parse_config_file"><b>parse_config_file</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int parse_config_file(const char *<i>fname</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#parse_config_file">src/dirtree.c</a><br>

<hr>
<a name="parse_group_expression"><b>parse_group_expression</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  array_header *parse_group_expression(pool *<i>p</i>, int *<i>argc</i>, char **<i>argv</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#parse_group_expression">src/dirtree.c</a><br>

<hr>
<a name="parse_user_expression"><b>parse_user_expression</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  array_header *parse_user_expression(pool *<i>p</i>, int *<i>argc</i>, char **<i>argv</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#parse_user_expression">src/dirtree.c</a><br>

<hr>
<a name="passwd_dup"><b>passwd_dup</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static struct passwd *passwd_dup(pool *<i>p</i>, struct passwd *<i>pw</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_auth.c.html#passwd_dup">modules/mod_auth.c</a><br>

<hr>
<a name="pcalloc"><b>pcalloc</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void *pcalloc(struct pool *<i>p</i>, int <i>size</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/pool.c.html#pcalloc">src/pool.c</a><br>

<hr>
<a name="pclosef"><b>pclosef</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int pclosef(pool *<i>p</i>, int <i>fd</i>)
</pre>
<font color=blue>Comments</font>:<br>
<br>
<font color=blue>See Also</font>:
<a href="#popenf"><code>popenf()</code></a><br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/pool.c.html#pclosef">src/pool.c</a><br>

<hr>
<a name="pdircat"><b>pdircat</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  char *pdircat(pool *<i>p</i>, ...)
</pre>
<font color=blue>Comments</font>:  Using the given <code>pool</code> <i>p</i>
for memory, this function will concatenate the given <code>char *</code>
arguments into a string, each element separated by a directory separator
character (<i>e.g.</i> <code>/</code>), to create a path.<br>
<br>
<font color=blue>Notes:</font> The argument list <i>must</i> end with a
<code>NULL</code>.  You have been warned.<br>
<br>
<font color=blue>See Also</font>:
<a href="#pstrcat"><code>pstrcat()</code></a><br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/pool.c.html#pdircat">src/pool.c</a><br>

<hr>
<a name="pfclose"><b>pfclose</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int pfclose(pool *<i>p</i>, FILE *<i>fp</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/pool.c.html#pfclose">src/pool.c</a><br>

<hr>
<a name="pfdopen"><b>pfdopen</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  FILE *pfdopen(pool *<i>p</i>, int <i>fd</i>, const char *<i>mode</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/pool.c.html#pfdopen">src/pool.c</a><br>

<hr>
<a name="pfopen"><b>pfopen</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  FILE *pfopen(pool *<i>p</i>, const char *<i>name</i>, const char *<i>mode</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/pool.c.html#pfopen">src/pool.c</a><br>

<hr>
<a name="pool_release_free_block_list"><b>pool_release_free_block_list</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void pool_release_free_block_list(void)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/pool.c.html#pool_release_free_block_list">src/pool.c</a><br>

<hr>
<a name="pop_cwd"><b>pop_cwd</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static void pop_cwd(char *<i>_cwd</i>, int *<i>symhold</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_ls.c.html#pop_cwd">modules/mod_ls.c</a><br>

<hr>
<a name="popenf"><b>popenf</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int popenf(pool *<i>p</i>, const char *<i>name</i>, int <i>flg</i>, int <i>mode</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/pool.c.html#popenf">src/pool.c</a><br>

<hr>
<a name="preparse_arg"><b>preparse_arg</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  char *preparse_arg(char **<i>s</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_log.c.html#preparse_arg">modules/mod_log.c</a><br>

<hr>
<a name="pr_alloc_netio"><b>pr_alloc_netio</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  pr_netio_t *pr_alloc_netio(pool *<i>parent_pool</i>)
</pre>
<font color=blue>Comments</font>:  Create a new <code>pr_netio_t</code> object,
allocating a subpool from <i>parent_pool</i> for the new object.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/netio.c.html#pr_alloc_netio">src/netio.c</a><br>

<hr>
<a name="pr_init_netio"><b>pr_init_netio</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void pr_init_netio(void)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/netio.c.html#pr_init_netio">src/netio.c</a><br>

<hr>
<a name="pr_init_pools"><b>pr_init_pools</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void pr_init_pools(void)
</pre>
<font color=blue>Comments</font>: Initialize the pool system by creating the
base <code>permanent_pool</code>.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/pool.c.html#pr_init_pools">src/pool.c</a><br>

<hr>
<a name="pr_netio_abort"><b>pr_netio_abort</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void pr_netio_abort(pr_netio_stream_t *<i>nstrm</i>)
</pre>
<font color=blue>Comments</font>:  This function sets the
<a href="macros.html#PR_NETIO_ABORT"><code>PR_NETIO_ABORT</code></a> flag on
the given <a href="structs.html#pr_netio_stream_t"><code>pr_netio_stream_t</code></a> <i>nstrm</i>.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/netio.c.html#pr_netio_abort">src/netio.c</a><br>

<hr>
<a name="pr_netio_close"><b>pr_netio_close</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int pr_netio_close(pr_netio_stream_t *<i>nstrm</i>)
</pre>
<font color=blue>Comments</font>:  Close <i>nstrm</i>'s file descriptor, and
destroy <i>nstrm</i>.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/netio.c.html#pr_netio_close">src/netio.c</a><br>

<hr>
<a name="pr_netio_gets"><b>pr_netio_gets</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  char *pr_netio_gets(char *<i>buf</i>, size_t <i>buflen</i>, pr_netio_stream_t *<i>nstrm</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/netio.c.html#pr_netio_gets">src/netio.c</a><br>

<hr>
<a name="pr_netio_lingering_close"><b>pr_netio_lingering_close</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int pr_netio_lingering_close(pr_netio_stream_t *<i>nstrm</i>, long <i>linger</i>)
</pre>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/netio.c.html#pr_netio_lingering_close">src/netio.c</a><br>

<hr>
<a name="pr_netio_open"><b>pr_netio_open</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  pr_netio_stream_t *pr_netio_open(pool *<i>parent_pool</i>, int <i>strm_type</i>, int <i>fd</i>, int <i>mode</i>)
</pre>
<font color=blue>Comments</font>:  Create a new <code>pr_netio_stream_t</code>
from <i>parent_pool</i>, and assign to it the file descriptor <i>fd</i> and
mode <i>mode</i>.  The <i>mode</i> argument must either
<code>PR_NETIO_IO_RD</code> for reading or <code>PR_NETIO_IO_WR</code> for
writing.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/netio.c.html#pr_netio_open">src/netio.c</a><br>

<hr>
<a name="pr_netio_poll"><b>pr_netio_poll</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int pr_netio_poll(pr_netio_stream_t *<i>nstrm</i>)
</pre>
<font color=blue>Comments</font>:  This function is needed instead of simply
blocking <code>read()</code>/<code>write()</code> because there is a race
condition if the syscall <i>should</i> be interrupted inside
<code>read()</code>, or <code>write()</code>, but the signal is received
before we actually hit the <code>read()</code> or <code>write()</code> call.
<code>select()</code> alleviates this problem by timing out (configurable
via <a href="#pr_netio_set_poll_interval"><code>pr_netio_set_poll_interval()</code></a>), restarting the syscall if <code>PR_NETIO_SESS_INTR</code> is not set,
or returning if it is set and we are interrupted by a signal.  If after the
timeout <code>PR_NETIO_SESS_ABORT</code> is set (presumably by a signal
handler) or <code>PR_NETIO_SESS_INTR</code> and <code>errno == EINTR</code>,
this function returns <code>1</code>.  Otherwise, return <code>0</code> when
data are available, <code>-1</code> if there are other errors.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/netio.c.html#pr_netio_poll">src/netio.c</a><br>

<hr>
<a name="pr_netio_postopen"><b>pr_netio_postopen</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int pr_netio_postopen(pr_netio_stream_t *<i>nstrm</i>)
</pre>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/netio.c.html#pr_netio_postopen">src/netio.c</a><br>

<hr>
<a name="pr_netio_printf"><b>pr_netio_printf</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int pr_netio_printf(pr_netio_stream_t *<i>nstrm</i>, char *<i>fmt</i>, ...)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/netio.c.html#pr_netio_printf">src/netio.c</a><br>

<hr>
<a name="pr_netio_printf_async"><b>pr_netio_printf_async</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int pr_netio_printf_async(pr_netio_stream_t *<i>nstrm</i>, char *<i>fmt</i>, ...)
</pre>
<font color=blue>Comments</font>:  This function is for use inside of
alarm handlers, where no
<a href="#pr_netio_poll"><code>pr_netio_poll()</code></a> blocking
is allowed.  This is necessary because otherwise
<a href="#pr_netio_poll"><code>pr_netio_poll()</code></a> can potentially hang
forever if the send queue is full and the socket has been closed.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/netio.c.html#pr_netio_printf_async">src/netio.c</a><br>

<hr>
<a name="pr_netio_read"><b>pr_netio_read</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int pr_netio_read(pr_netio_stream_t *<i>nstrm</i>, char *<i>buf</i>, size_t <i>buflen</i>, int <i>bufmin</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/netio.c.html#pr_netio_read">src/netio.c</a><br>

<hr>
<a name="pr_netio_reopen"><b>pr_netio_reopen</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  pr_netio_stream_t *pr_netio_reopen(pr_netio_stream_t *<i>nstrm</i>, int <i>fd</i>, int <i>mode</i>)
</pre>
<font color=blue>Comments</font>:  Close <i>nstrm</i>'s current file descriptor,
and assign to <i>nstrm</i> the new file descriptor <i>fd</i> and mode
<i>mode</i>.  The <i>mode</i> argument must be either
<code>PR_NETIO_IO_RD</code> for reading or <code>PR_NETIO_IO_WR</code> for
writing.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/netio.c.html#pr_netio_reopen">src/netio.c</a><br>

<hr>
<a name="pr_netio_set_poll_interval"><b>pr_netio_set_poll_interval</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void pr_netio_set_poll_interval(pr_netio_stream_t *<i>nstrm</i>, unsigned int <i>secs</i>)
</pre>
<font color=blue>Comments</font>:  Sets the
<a href="macros.html#PR_NETIO_SESS_INTR"><code>PR_NETIO_SESS_INTR</code></a>
flag for <i>nstrm</i>, and configures the <code>select()</code> timeout used in
<a href="#pr_netio_poll"><code>pr_netio_poll()</code></a> to <i>secs</i>.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/netio.c.html#pr_netio_set_poll_interval">src/netio.c</a><br>

<hr>
<a name="pr_netio_telnet_gets"><b>pr_netio_telnet_gets</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  char *pr_netio_telnet_gets(char *<i>buf</i>, size_t <i>buflen</i>, pr_netio_stream_t *<i>in_nstrm</i>,
      pr_netio_stream_t *<i>out_nstrm</i>)
</pre>
<font color=blue>Comments</font>:  This function is exactly like
<a href="#pr_netio_gets"><code>pr_netio_gets()</code></a>, except that a few
special telnet characters are handled, which takes care of the
[<code>IAC</code>]<code>ABOR</code> command, and odd clients.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/netio.c.html#pr_netio_telnet_gets">src/netio.c</a><br>

<hr>
<a name="pr_netio_write"><b>pr_netio_write</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int pr_netio_write(pr_netio_stream_t *<i>nstrm</i>, char *<i>buf</i>, size_t <i>buflen</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/netio.c.html#pr_netio_write">src/netio.c</a><br>

<hr>
<a name="pr_netio_write_async"><b>pr_netio_write_async</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int pr_netio_write_async(pr_netio_stream_t *<i>nstrm</i>, char *<i>buf</i>, size_t <i>buflen</i>)
</pre>
<font color=blue>Comments</font>: This is a bit odd, because
<code>pr_netio_*</code> functions are opaque, and we cannot be sure that we are
dealing with a <code>conn_t</code> or that it is in <code>O_NONBLOCK</code>
mode.  Trying to do this without <code>O_NONBLOCK</code> would cause the kernel
itself to block here, and thus invalidate the whole principle.  Instead, we
save the flags and put the file descriptor in <code>O_NONBLOCK</code> mode.<br>
<br>
This function returns <code>-1</code> if an error occurred, and
<code>errno</code> is set appropriately.  If everything goes smoothly,
the number of bytes written is returned.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/netio.c.html#pr_netio_write_async">src/netio.c</a><br>

<hr>
<a name="pstrcat"><b>pstrcat</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  char *pstrcat(pool *<i>p</i>, ...)
</pre>
<font color=blue>Comments</font>: Using the given <code>pool</code> <i>p</i>
for memory, this function will concatenate the given <code>char *</code>
arguments into a string.<br>
<br>
<font color=blue>Notes:</font>  The argument list <i>must</i> end with a
<code>NULL</code>.  You have been warned.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/pool.c.html#pstrcat">src/pool.c</a><br>

<hr>
<a name="pstrdup"><b>pstrdup</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  char *pstrdup(struct pool *<i>p</i>, const char *<i>s</i>)
</pre>
<font color=blue>Comments</font>: This function returns a pointer to a new
string, <code>NUL</code>-terminated, which is a duplicate of the string
<i>s</i>.  Memory for the new string is obtained from the given
<code>pool</code> <i>p</i>, and is freed when that <code>pool</code> is
destroyed.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/pool.c.html#pstrdup">src/pool.c</a><br>

<hr>
<a name="pstrndup"><b>pstrndup</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  char *pstrndup(struct pool *<i>p</i>, const char *<i>s</i>, int <i>n</i>)
</pre>
<font color=blue>Comments</font>: Similar to <code>pstrdup()</code>, this
function returns a pointer to a new string, <code>NUL</code>-terminated, which
is a duplicate of the first <i>n</i> characters of the string <i>s</i>.
Memory for the new string is obtained from the given <code>pool</code>
<i>p</i>, and is freed when that <code>pool</code> is destroyed.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/pool.c.html#pstrndup">src/pool.c</a><br>

<hr>
<a name="push_array"><b>push_array</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void *push_array(array_header *<i>arr</i>)
</pre>
<font color=blue>Comments</font>: This function returns a void pointer to
a slot in the <code>array_header</code> <i>arr</i> into which a pointer to
some element can be copied, in effect &quot;pushing&quot; that new element
onto the array. <code>array_header</code>s will be grown as needed as more
elements are pushed onto them.  Pushed elements appear at the <i>end</i> of the
<code>array_header</code>'s list of elements, not the beginning.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/pool.c.html#push_array">src/pool.c</a><br>

<hr>
<a name="push_cwd"><b>push_cwd</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static void push_cwd(char *<i>_cwd</i>, int *<i>symhold</i>) {
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_ls.c.html#push_cwd">modules/mod_ls.c</a><br>

<hr>
<a name="pw_auth"><b>pw_auth</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET pw_auth(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_unixpw.c.html#pw_auth">modules/mod_unixpw.c</a><br>

<hr>
<a name="pw_check"><b>pw_check</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET pw_check(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_unixpw.c.html#pw_check">modules/mod_unixpw.c</a><br>

<hr>
<a name="pw_endgrent"><b>pw_endgrent</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET pw_endgrent(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_unixpw.c.html#pw_endgrent">modules/mod_unixpw.c</a><br>

<hr>
<a name="pw_endpwent"><b>pw_endpwent</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET pw_endpwent(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_unixpw.c.html#pw_endpwent">modules/mod_unixpw.c</a><br>

<hr>
<a name="pw_getgrent"><b>pw_getgrent</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET pw_getgrent(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_unixpw.c.html#pw_getgrent">modules/mod_unixpw.c</a><br>

<hr>
<a name="pw_getgrgid"><b>pw_getgrgid</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET pw_getgrgid(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_unixpw.c.html#pw_getgrgid">modules/mod_unixpw.c</a><br>

<hr>
<a name="pw_getgrnam"><b>pw_getgrnam</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET pw_getgrnam(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_unixpw.c.html#pw_getgrnam">modules/mod_unixpw.c</a><br>

<hr>
<a name="pw_getgroups"><b>pw_getgroups</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET pw_getgroups(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_unixpw.c.html#pw_getgroups">modules/mod_unixpw.c</a><br>

<hr>
<a name="pw_getpwent"><b>pw_getpwent</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET pw_getpwent(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_unixpw.c.html#pw_getpwent">modules/mod_unixpw.c</a><br>

<hr>
<a name="pw_getpwnam"><b>pw_getpwnam</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET pw_getpwnam(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_unixpw.c.html#pw_getpwnam">modules/mod_unixpw.c</a><br>

<hr>
<a name="pw_getpwuid"><b>pw_getpwuid</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET pw_getpwuid(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_unixpw.c.html#pw_getpwuid">modules/mod_unixpw.c</a><br>

<hr>
<a name="pw_gid_name"><b>pw_gid_name</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
 i MODRET pw_gid_name(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_unixpw.c.html#pw_gid_name">modules/mod_unixpw.c</a><br>

<hr>
<a name="pw_name_gid"><b>pw_name_gid</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET pw_name_gid(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_unixpw.c.html#pw_name_gid">modules/mod_unixpw.c</a><br>

<hr>
<a name="pw_name_uid"><b>pw_name_uid</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET pw_name_uid(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_unixpw.c.html#pw_name_uid">modules/mod_unixpw.c</a><br>

<hr>
<a name="pw_setgrent"><b>pw_setgrent</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET pw_setgrent(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_unixpw.c.html#pw_setgrent">modules/mod_unixpw.c</a><br>

<hr>
<a name="pw_setpwent"><b>pw_setpwent</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET pw_setpwent(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_unixpw.c.html#pw_setpwent">modules/mod_unixpw.c</a><br>

<hr>
<a name="pw_uid_name"><b>pw_uid_name</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET pw_uid_name(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_unixpw.c.html#pw_uid_name">modules/mod_unixpw.c</a><br>

<hr>
<a name="quote_dir"><b>quote_dir</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static char *quote_dir(cmd_rec *<i>cmd</i>, char *<i>dir</i>)
</pre>
<font color=blue>Comments</font>:  As per RFC 959, directory responses for
<code>MKD</code> and <code>PWD</code> should be &quot;dir_name&quot; (with
quotes).  For directory names that themselves contain quotes, the additional
quotes must be duplicated.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#quote_dir">modules/mod_core.c</a><br>

<hr>
<a name="regex_filters"><b>regex_filters</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET regex_filters(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#regex_filters">modules/mod_core.c</a><br>

<hr>
<a name="register_cleanup"><b>register_cleanup</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void register_cleanup(pool *<i>p</i>, void *<i>data</i>, void (*<i>plain_cleanup</i>)(void *),
    void (*<i>child_cleanup</i>)(void *))
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/pool.c.html#register_cleanup">src/pool.c</a><br>

<hr>
<a name="register_fd_cleanups"><b>register_fd_cleanups</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void register_fd_cleanups(pool *<i>p</i>, int <i>fd</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/pool.c.html#register_fd_cleanups">src/pool.c</a><br>

<hr>
<a name="register_file_cleanups"><b>register_file_cleanups</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void register_file_cleanups(pool *<i>p</i>, FILE *<i>fp</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/pool.c.html#register_file_cleanups">src/pool.c</a><br>

<hr>
<a name="register_rehash"><b>register_rehash</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void register_rehash(void *<i>data</i>, void (*<i>fp</i>)(void *))
</pre>
<font color=blue>Comments</font>:  Registers a function <i>fp</i> to be run
when the server receives a <code>SIGHUP</code>, which causes it to
&quot;rehash&quot; the configuration file.  The function <i>fp</i> will be
called before the configuration file is rehashed, and will be passed the
given <i>data</i> pointer.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/main.c.html#register_rehash">src/main.c</a><br>

<hr>
<a name="remove_config"><b>remove_config</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int remove_config(xaset_t *<i>set</i>, const char *<i>name</i>, int <i>recurse</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#remove_config">src/dirtree.c</a><br>

<hr>
<a name="remove_exit_handlers"><b>remove_exit_handlers</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void remove_exit_handlers(void)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/support.c.html#remove_exit_handlers">src/support.c</a><br>

<hr>
<a name="remove_timer"><b>remove_timer</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int remove_timer(int <i>timerno</i>, module *<i>mod</i>)
</pre>
<font color=blue>Comments</font>:  Removes an active timer from play. The
timer must have the <i>timerno</i> given, and be registered by module
<i>mod</i>.  If found, the <i>timerno</i> is returned, otherwise 0 is returned.
As a special case, the macro <code>ANY_MODULE</code> may be used for the
<i>mod</i> argument, in which case a timer with the given <i>timerno</i> will
be removed, regardless of the registering module.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/timers.c.html#remove_timer">src/timers.c</a><br>

<hr>
<a name="reset_timer"><b>reset_timer</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int reset_timer(int <i>timerno</i>, module *<i>mod</i>)
</pre>
<font color=blue>Comments</font>:  Resets the time on an active timer. The
timer must have the <i>timerno</i> given, and be registered by module
<i>mod</i>.  If found, the <i>timerno</i> is returned, otherwise 0 is returned.
As a special case, the macro <code>ANY_MODULE</code> may be used for the
<i>mod</i> argument, in which case a timer with the given <i>timerno</i> will
be removed, regardless of the registering module.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/timers.c.html#reset_timer">src/timers.c</a><br>

<hr>
<a name="resolve_anonymous_dirs"><b>resolve_anonymous_dirs</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void resolve_anonymous_dirs(xaset_t *<i>clist</i>)
</pre>
<font color=blue>Comments</font>: Iterate through <code>&lt;Directory&gt;</code>
blocks inside of an <code>&lt;Anonymous&gt;</code> context, and resolve
each one.  This is usually done after a connection has been made to an
<code>&lt;Anonymous&gt;</code> server.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#resolve_anonymous_dirs">src/dirtree.c</a><br>

<hr>
<a name="resolve_defered_dirs"><b>resolve_defered_dirs</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void resolve_defered_dirs(server_rec *<i>s</i>)
</pre>
<font color=blue>Comments</font>: Iterate through <code>&lt;Directory&gt;</code>
configuration records and resolve <code>~</code> references.  This function
is usually called after a connection has been made to a server.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#resolve_defered_dirs">src/dirtree.c</a><br>

<hr>
<a name="retr_abort"><b>retr_abort</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static void retr_abort(void)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_xfer.c.html#retr_abort">modules/mod_xfer.c</a><br>

<hr>
<a name="retr_complete"><b>retr_complete</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static void retr_complete(void)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_xfer.c.html#retr_complete">modules/mod_xfer.c</a><br>

<hr>
<a name="run_cleanups"><b>run_cleanups</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static void run_cleanups(struct cleanup *<i>c</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/pool.c.html#run_cleanups">src/pool.c</a><br>

<hr>
<a name="run_exit_handlers"><b>run_exit_handlers</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void run_exit_handlers(void)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/support.c.html#run_exit_handlers">src/support.c</a><br>

<hr>
<a name="run_schedule"><b>run_schedule</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void run_schedule(void)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/support.c.html#run_schedule">src/support.c</a><br>

<hr>
<a name="safe_token"><b>safe_token</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  char *safe_token(char **<i>s</i>)
</pre>
<font color=blue>Comments</font>:  This function tokenizes a string <i>s</i>,
returning the next token in the string, and incrementing the <i>s</i>
pointer to the next non-whitespace character in the string.  It is
&quot;safe&quot; because it never returns <code>NULL</code>, only an empty
string if no token remains in the source string.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/support.c.html#safe_token">src/support.c</a><br>

<hr>
<a name="schedule"><b>schedule</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void schedule(void (*<i>f</i>)(void *, void *, void *, void *), int <i>nloops</i>, void *<i>a1</i>, void *<i>a2</i>,
    void *<i>a3</i>, void *<i>a4</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/support.c.html#schedule">src/support.c</a><br>

<hr>
<a name="semaphore_fds"><b>semaphore_fds</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int semaphore_fds(fd_set *<i>rfd</i>, int <i>max_fd</i>)
</pre>
<font color=blue>Comments</font>: Adds child semaphore fds into the <i>rfd</i>
set for selection.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/main.c.html#semaphore_fds">src/main.c</a><br>

<hr>
<a name="send_response"><b>send_response</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void send_response(const char *<i>resp_numeric</i>, const char *<i>fmt</i>, ...)
</pre>
<font color=blue>Comments</font>: This function will immediately send
the given message, accompanied by the specific <i>numeric</i>, to the
connected client.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/main.c.html#send_response">src/main.c</a><br>

<hr>
<a name="send_response_async"><b>send_response_async</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void send_response_async(const char *<i>resp_numeric</i>, const char *<i>fmt</i>, ...)
</pre>
<font color=blue>Comments</font>:  This function will send an
asynchronous message to the client, with the given <i>numeric</i>; it is
suitable for use inside of signal handlers.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/main.c.html#send_response_async">src/main.c</a><br>

<hr>
<a name="send_response_list"><b>send_response_list</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static void send_response_list(response_t **<i>head</i>)
</pre>
<font color=blue>Comments</font>: Flushes the response chain <i>head</i> out to
the connected client.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/main.c.html#send_response_list">src/main.c</a><br>

<hr>
<a name="send_response_ml"><b>send_response_ml</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void send_response_ml(const char *<i>fmt</i>, ...)
</pre>
<font color=blue>Comments</font>:  This function continues a previous
multiline response, using the specified <i>numeric</i>, started by a
<a href="#send_response_ml_start"><code>send_response_ml_start()</code></a>
call.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/main.c.html#send_response_ml">src/main.c</a><br>

<hr>
<a name="send_response_ml_end"><b>send_response_ml_end</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void send_response_ml_end(const char *<i>fmt</i>, ...)
</pre>
<font color=blue>Comments</font>:  This function completes a multiline
response.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/main.c.html#send_response_ml_end">src/main.c</a><br>

<hr>
<a name="send_response_ml_start"><b>send_response_ml_start</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void send_response_ml_start(const char *<i>resp_numeric</i>, const char *<i>fmt</i>, ...)
</pre>
<font color=blue>Comments</font>:  This function begins a multiline
FTP protocol response with the given <i>numeric</i>.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/main.c.html#send_response_ml_start">src/main.c</a><br>

<hr>
<a name="send_response_raw"><b>send_response_raw</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void send_response_raw(const char *<i>fmt</i>, ...)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/main.c.html#send_response_raw">src/main.c</a><br>

<hr>
<a name="sendline"><b>sendline</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int sendline(char *<i>fmt</i>, ...)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_ls.c.html#sendline">modules/mod_ls.c</a><br>

<hr>
<a name="serv_conn_cleanup_cb"><b>serv_conn_cleanup_cb</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static void serv_conn_cleanup_cb(void *<i>connp</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/main.c.html#serv_conn_cleanup_cb">src/main.c</a><br>

<hr>
<a name="server_loop"><b>server_loop</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void server_loop(void)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/main.c.html#server_loop">src/main.c</a><br>

<hr>
<a name="set_accessdenymsg"><b>set_accessdenymsg</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_accessdenymsg(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>AccessDenyMsg</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_accessdenymsg">modules/mod_core.c</a><br>

<hr>
<a name="set_accessgrantmsg"><b>set_accessgrantmsg</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_accessgrantmsg(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>AccessGrantMsg</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_accessgrantmsg">modules/mod_core.c</a><br>

<hr>
<a name="set_allowall"><b>set_allowall</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_allowall(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>AllowAll</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_allowall">modules/mod_core.c</a><br>

<hr>
<a name="set_allowfilter"><b>set_allowfilter</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_allowfilter(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>AllowFilter</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_allowfilter">modules/mod_core.c</a><br>

<hr>
<a name="set_allowforeignaddress"><b>set_allowforeignaddress</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_allowforeignaddress(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>AllowForeignAddress</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_allowforeignaddress">modules/mod_core.c</a><br>

<hr>
<a name="set_allowlogsymlinks"><b>set_allowlogsymlinks</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_allowlogsymlinks(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>AllowLogSymlinks</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_log.c.html#set_allowlogsymlinks">modules/mod_log.c</a><br>

<hr>
<a name="set_allowoverride"><b>set_allowoverride</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_allowoverride(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>AllowOverride</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_allowoverride">modules/mod_core.c</a><br>

<hr>
<a name="set_allowoverwrite"><b>set_allowoverwrite</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_allowoverwrite(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>AllowOverwrite</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_xfer.c.html#set_allowoverwrite">modules/mod_xfer.c</a><br>

<hr>
<a name="set_allowretrieverestart"><b>set_allowretrieverestart</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_allowretrieverestart(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>AllowRetrieveRestart</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_allowretrieverestart">modules/mod_core.c</a><br>

<hr>
<a name="set_allowstorerestart"><b>set_allowstorerestart</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_allowstorerestart(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>AllowStoreRestart</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_allowstorerestart">modules/mod_core.c</a><br>

<hr>
<a name="set_anonrequirepassword"><b>set_anonrequirepassword</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_anonrequirepassword(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>AnonRequirePassword</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_anonrequirepassword">modules/mod_core.c</a><br>

<hr>
<a name="set_auth_check"><b>set_auth_check</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void set_auth_check(int (*<i>ck</i>)(cmd_rec *))
</pre>
<font color=blue>Comments</font>:  Sets a function <i>ck</i> to be invoked
in order to verify that a given FTP command in the form of a
<code>cmd_rec</code> is authorized.  Usually this function prevents FTP
commands from being processed unless the client has successfully authenticated
via <code>USER</code>/<code>PASS</code> commands.  Specific FTP commands
are subject to this authorization check via one of the <code>cmdtable</code>
Boolean fields.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/main.c.html#set_auth_check">src/main.c</a><br>

<hr>
<a name="set_authaliasonly"><b>set_authaliasonly</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_authaliasonly(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>AuthAliasOnly</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_authaliasonly">modules/mod_core.c</a><br>

<hr>
<a name="set_authgroupfile"><b>set_authgroupfile</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_authgroupfile(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>AuthGroupFile</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_unixpw.c.html#set_authgroupfile">modules/mod_unixpw.c</a><br>

<hr>
<a name="set_authpam"><b>set_authpam</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_authpam(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>AuthPAM</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_pam.c.html#set_authpam">modules/mod_pam.c</a><br>

<hr>
<a name="set_authpamauthoritative"><b>set_authpamauthoritative</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_authpamauthoritative(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>AuthPAMAuthoritative</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_pam.c.html#set_authpamauthoritative">modules/mod_pam.c</a><br>

<hr>
<a name="set_authpamconfig"><b>set_authpamconfig</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_authpamconfig(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>AuthPAMConfig</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_pam.c.html#set_authpamconfig">modules/mod_pam.c</a><br>

<hr>
<a name="set_authuserfile"><b>set_authuserfile</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_authuserfile(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>AuthUserFile</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_unixpw.c.html#set_authuserfile">modules/mod_unixpw.c</a><br>

<hr>
<a name="set_authusingalias"><b>set_authusingalias</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_authusingalias(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>AuthUsingAlias</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_authusingalias">modules/mod_core.c</a><br>

<hr>
<a name="set_class"><b>set_class</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_class(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>Class</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_class">modules/mod_core.c</a><br>

<hr>
<a name="set_classes"><b>set_classes</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_classes(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>Classes</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_classes">modules/mod_core.c</a><br>

<hr>
<a name="set_commandbuffersize"><b>set_commandbuffersize</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_commandbuffersize(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>CommandBufferSize</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_commandbuffersize">modules/mod_core.c</a><br>

<hr>
<a name="set_daemon_rlimits"><b>set_daemon_rlimits</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void set_daemon_rlimits(void)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/main.c.html#set_daemon_rlimits">src/main.c</a><br>

<hr>
<a name="set_defaultaddress"><b>set_defaultaddress</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_defaultaddress(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>DefaultAddress</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_defaultaddress">modules/mod_core.c</a><br>

<hr>
<a name="set_defaultserver"><b>set_defaultserver</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_defaultserver(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>DefaultServer</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_defaultserver">modules/mod_core.c</a><br>

<hr>
<a name="set_defaulttransfermode"><b>set_defaulttransfermode</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_defaulttransfermode(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>DefaultTransferMode</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_defaulttransfermode">modules/mod_core.c</a><br>

<hr>
<a name="set_deferwelcome"><b>set_deferwelcome</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_deferwelcome(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>DeferWelcome</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_deferwelcome">modules/mod_core.c</a><br>

<hr>
<a name="set_deleteabortedstores"><b>set_deleteabortedstores</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_deleteabortedstores(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>DeleteAbortedStores</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_deleteabortedstores">modules/mod_core.c</a><br>

<hr>
<a name="set_denyall"><b>set_denyall</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_denyall(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>DenyAll</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_denyall">modules/mod_core.c</a><br>

<hr>
<a name="set_denyfilter"><b>set_denyfilter</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_denyfilter(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>DenyFilter</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_denyfilter">modules/mod_core.c</a><br>

<hr>
<a name="set_dirfakegroup"><b>set_dirfakegroup</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_dirfakegroup(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>DirFakeGroup</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_ls.c.html#set_dirfakegroup">modules/mod_ls.c</a><br>

<hr>
<a name="set_dirfakemode"><b>set_dirfakemode</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_dirfakemode(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>DirFakeMode</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_ls.c.html#set_dirfakemode">modules/mod_ls.c</a><br>

<hr>
<a name="set_dirfakeuser"><b>set_dirfakeuser</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_dirfakeuser(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>DirFakeUser</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_ls.c.html#set_dirfakeuser">modules/mod_ls.c</a><br>

<hr>
<a name="set_displayconnect"><b>set_displayconnect</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_displayconnect(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>DisplayConnect</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_displayconnect">modules/mod_core.c</a><br>

<hr>
<a name="set_displayfirstchdir"><b>set_displayfirstchdir</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_displayfirstchdir(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>DisplayFirstChdir</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_displayfirstchdir">modules/mod_core.c</a><br>

<hr>
<a name="set_displaygoaway"><b>set_displaygoaway</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
 i MODRET set_displaygoaway(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>DisplayGoAway</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_displaygoaway">modules/mod_core.c</a><br>

<hr>
<a name="set_displaylogin"><b>set_displaylogin</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_displaylogin(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>DisplayLogin</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_displaylogin">modules/mod_core.c</a><br>

<hr>
<a name="set_displayquit"><b>set_displayquit</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_displayquit(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>DisplayQuit</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_displayquit">modules/mod_core.c</a><br>

<hr>
<a name="set_group"><b>set_group</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_group(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>Group</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_group">modules/mod_core.c</a><br>

<hr>
<a name="set_grouppassword"><b>set_grouppassword</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_grouppassword(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>GroupPassword</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_auth.c.html#set_grouppassword">modules/mod_core.c</a><br>

<hr>
<a name="set_groups"><b>set_groups</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int set_groups(pool *<i>p</i>, gid_t <i>primary_gid</i>, array_header *<i>suppl_gids</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/auth.c.html#set_groups">src/auth.c</a><br>

<hr>
<a name="set_hiddenstores"><b>set_hiddenstores</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_hiddenstores(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>HiddenStores</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_xfer.c.html#set_hiddenstores">modules/mod_xfer.c</a><br>

<hr>
<a name="set_hidefiles"><b>set_hidefiles</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_hidefiles(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>HideFiles</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_hidefiles">modules/mod_core.c</a><br>

<hr>
<a name="set_hidenoaccess"><b>set_hidenoaccess</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_hidenoaccess(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>HideNoAccess</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_hidenoaccess">modules/mod_core.c</a><br>

<hr>
<a name="set_identlookups"><b>set_identlookups</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_identlookups(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>IdentLookups</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_identlookups">modules/mod_core.c</a><br>

<hr>
<a name="set_ignorehidden"><b>set_ignorehidden</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_ignorehidden(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>IgnoreHidden</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_ignorehidden">modules/mod_core.c</a><br>

<hr>
<a name="set_loginpasswordprompt"><b>set_loginpasswordprompt</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_loginpasswordprompt(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>LoginPasswordPrompt</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_auth.c.html#set_loginpasswordprompt">modules/mod_auth.c</a><br>

<hr>
<a name="set_lsdefaultoptions"><b>set_lsdefaultoptions</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_lsdefaultoptions(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>LsDefaultOptions</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_ls.c.html#set_lsdefaultoptions">modules/mod_ls.c</a><br>

<hr>
<a name="set_maxclients"><b>set_maxclients</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_maxclients(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>MaxClients</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_maxclients">modules/mod_core.c</a><br>

<hr>
<a name="set_maxconnrate"><b>set_maxconnrate</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_maxconnrate(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>MaxConnectionRate</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_maxconnrate">modules/mod_core.c</a><br>

<hr>
<a name="set_maxfilesize"><b>set_maxfilesize</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_maxfilesize(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>MaxRetrieveFileSize</code> and <code>MaxStoreFileSize</code>
directives.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_xfer.c.html#set_maxconnrate">modules/mod_xfer.c</a><br>

<hr>
<a name="set_maxhostclients"><b>set_maxhostclients</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_maxhostclients(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>MaxClientsPerHost</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_maxhostclients">modules/mod_core.c</a><br>

<hr>
<a name="set_maxhostsperuser"><b>set_maxhostsperuser</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_maxhostsperuser(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>MaxHostsPerUser</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_maxhostsperuser">modules/mod_core.c</a><br>

<hr>
<a name="set_maxinstances"><b>set_maxinstances</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_maxinstances(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>MaxInstances</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_maxinstances">modules/mod_core.c</a><br>

<hr>
<a name="set_maxloginattempts"><b>set_maxloginattempts</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_maxloginattempts(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>MaxLoginAttempts</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_maxloginattempts">modules/mod_core.c</a><br>

<hr>
<a name="set_multilinerfc2228"><b>set_multilinerfc2228</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_multilinerfc2228(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>MultilineRFC2228</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_multilinerfc2228">modules/mod_core.c</a><br>

<hr>
<a name="set_passiveports"><b>set_passiveports</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_passiveports(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>PassivePorts</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_passiveports">modules/mod_core.c</a><br>

<hr>
<a name="set_pathallowfilter"><b>set_pathallowfilter</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_pathallowfilter(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>PathAllowFilter</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_pathallowfilter">modules/mod_core.c</a><br>

<hr>
<a name="set_pathdenyfilter"><b>set_pathdenyfilter</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_pathdenyfilter(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>PathDenyFilter</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_pathdenyfilter">modules/mod_core.c</a><br>

<hr>
<a name="set_persistentpasswd"><b>set_persistentpasswd</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_persistentpasswd(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>PersistentPasswd</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_unixpw.c.html#set_persistentpasswd">modules/mod_unixpw.c</a><br>

<hr>
<a name="set_pidfile"><b>set_pidfile</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_pidfile(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>PidFile</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_pidfile">modules/mod_core.c</a><br>

<hr>
<a name="set_proc_title"><b>set_proc_title</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static void set_proc_title(char *<i>fmt</i>, ...)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/main.c.html#set_proc_title">src/main.c</a><br>

<hr>
<a name="set_regex"><b>set_regex</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_regex(cmd_rec *<i>cmd</i>, char *<i>param</i>, char *<i>type</i>) {
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_regex">modules/mod_core.c</a><br>

<hr>
<a name="set_requirevalidshell"><b>set_requirevalidshell</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_requirevalidshell(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>RequireValidShell</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_requirevalidshell">modules/mod_core.c</a><br>

<hr>
<a name="set_rlimitcpu"><b>set_rlimitcpu</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_rlimitcpu(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>RLimitCPU</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_rlimitcpu">modules/mod_core.c</a><br>

<hr>
<a name="set_rlimitmemory"><b>set_rlimitmemory</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_rlimitmemory(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>RLimitMemory</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_rlimitmemory">modules/mod_core.c</a><br>

<hr>
<a name="set_rlimitopenfiles"><b>set_rlimitopenfiles</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_rlimitopenfiles(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>RLimitOpenFiles</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_rlimitopenfiles">modules/mod_core.c</a><br>

<hr>
<a name="set_rootlogin"><b>set_rootlogin</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_rootlogin(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>RootLogin</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_auth.c.html#set_rootlogin">modules/mod_auth.c</a><br>

<hr>
<a name="set_scoreboardfile"><b>set_scoreboardfile</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_scoreboardfile(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>ScoreboardFile</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_scoreboardfile">modules/mod_core.c</a><br>

<hr>
<a name="set_serveradmin"><b>set_serveradmin</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_serveradmin(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>ServerAdmin</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_serveradmin">modules/mod_core.c</a><br>

<hr>
<a name="set_serverident"><b>set_serverident</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_serverident(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>ServerIdent</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_serverident">modules/mod_core.c</a><br>

<hr>
<a name="set_servername"><b>set_servername</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_servername(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>:  Configuration directive handler for the
<code>ServerName</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_servername">modules/mod_core.c</a><br>

<hr>
<a name="set_serverport"><b>set_serverport</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_serverport(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>Port</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_serverport">modules/mod_core.c</a><br>

<hr>
<a name="set_servertype"><b>set_servertype</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_servertype(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>ServerType</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_servertype">modules/mod_core.c</a><br>

<hr>
<a name="set_server_privs"><b>set_server_privs</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static void set_server_privs(void)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/main.c.html#set_server_privs">src/main.c</a><br>

<hr>
<a name="set_session_rlimits"><b>set_session_rlimits</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void set_session_rlimits(void)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/main.c.html#set_session_rlimits">src/main.c</a><br>

<hr>
<a name="set_showsymlinks"><b>set_showsymlinks</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_showsymlinks(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>ShowSymlinks</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_showsymlinks">modules/mod_core.c</a><br>

<hr>
<a name="set_sig_alarm"><b>set_sig_alarm</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void set_sig_alarm(void)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/timers.c.html#set_sig_alarm">src/timers.c</a><br>

<hr>
<a name="set_socketbindtight"><b>set_socketbindtight</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_socketbindtight(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>SocketBindTight</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_socketbindtight">modules/mod_core.c</a><br>

<hr>
<a name="set_storeuniqueprefix"><b>set_storeuniqueprefix</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_storeuniqueprefix(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>StoreUniquePrefix</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_xfer.c.html#set_storeuniqueprefix">modules/mod_xfer.c</a><br>

<hr>
<a name="set_syslogfacility"><b>set_syslogfacility</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_syslogfacility(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>SyslogFacility</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_syslogfacility">modules/mod_core.c</a><br>

<hr>
<a name="set_sysloglevel"><b>set_sysloglevel</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_sysloglevel(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>SyslogLevel</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_sysloglevel">modules/mod_core.c</a><br>

<hr>
<a name="set_systemlog"><b>set_systemlog</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_systemlog(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>SystemLog</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_log.c.html#set_systemlog">modules/mod_log.c</a><br>

<hr>
<a name="set_tcpbacklog"><b>set_tcpbacklog</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_tcpbacklog(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>tcpBackLog</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_tcpbacklog">modules/mod_core.c</a><br>

<hr>
<a name="set_tcpnodelay"><b>set_tcpnodelay</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_tcpnodelay(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>tcpNoDelay</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_tcpnodelay">modules/mod_core.c</a><br>

<hr>
<a name="set_tcpreceivewindow"><b>set_tcpreceivewindow</b><br>
<br>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>tcpReceiveWindow</code> directive.<br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_tcpreceivewindow(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_tcpreceivewindow">modules/mod_core.c</a><br>

<hr>
<a name="set_tcpsendwindow"><b>set_tcpsendwindow</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_tcpsendwindow(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>tcpSendWindow</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_tcpsendwindow">modules/mod_core.c</a><br>

<hr>
<a name="set_timeoutidle"><b>set_timeoutidle</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_timeoutidle(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>TimeoutIdle</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_timeoutidle">modules/mod_core.c</a><br>

<hr>
<a name="set_timeoutlogin"><b>set_timeoutlogin</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_timeoutlogin(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>TimeoutLogin</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_auth.c.html#set_timeoutlogin">modules/mod_auth.c</a><br>

<hr>
<a name="set_timeoutnoxfer"><b>set_timeoutnoxfer</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_timeoutnoxfer(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>TimeoutNoTransfer</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_timeoutnoxfer">modules/mod_core.c</a><br>

<hr>
<a name="set_timeoutsession"><b>set_timeoutsession</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_timeoutsession(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>TimeoutSession</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_auth.c.html#set_timeoutsession">modules/mod_auth.c</a><br>

<hr>
<a name="set_timeoutstalled"><b>set_timeoutstalled</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_timeoutstalled(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>TimeoutStalled</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_timeoutstalled">modules/mod_core.c</a><br>

<hr>
<a name="set_timesgmt"><b>set_timesgmt</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_timesgmt(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>TimesGMT</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_timesgmt">modules/mod_core.c</a><br>

<hr>
<a name="set_umask"><b>set_umask</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_umask(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>Umask</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_umask">modules/mod_core.c</a><br>

<hr>
<a name="set_useftpusers"><b>set_useftpusers</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_useftpusers(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>UseFtpUsers</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_useftpusers">modules/mod_core.c</a><br>

<hr>
<a name="set_useglobbing"><b>set_useglobbing</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_useglobbing(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>UseGlobbing</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_ls.c.html#set_useglobbing">modules/mod_ls.c</a><br>

<hr>
<a name="set_user"><b>set_user</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_user(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>User</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_user">modules/mod_core.c</a><br>

<hr>
<a name="set_useralias"><b>set_useralias</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_useralias(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>UserAlias</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_auth.c.html#set_useralias">modules/mod_core.c</a><br>

<hr>
<a name="set_userpassword"><b>set_userpassword</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_userpassword(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>UserPassword</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_auth.c.html#set_userpassword">modules/mod_core.c</a><br>


<hr>
<a name="set_usereversedns"><b>set_usereversedns</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_usereversedns(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>UseReverseDNS</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_usereversedns">modules/mod_core.c</a><br>

<hr>
<a name="set_wtmplog"><b>set_wtmplog</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET set_wtmplog(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>WtmpLog</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#set_wtmplog">modules/mod_core.c</a><br>

<hr>
<a name="show_usage"><b>show_usage</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static void show_usage(char *<i>progname</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/ftpshut.c.html#show_usage">src/ftpshut.c</a><br>

<hr>
<a name="shutdown_exit"><b>shutdown_exit</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void shutdown_exit(void *<i>d1</i>, void *<i>d2</i>, void *<i>d3</i>, void *<i>d4</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/main.c.html#shutdown_exit">src/main.c</a><br>

<hr>
<a name="sig_abort"><b>sig_abort</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static RETSIGTYPE sig_abort(int <i>sig</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/main.c.html#sig_abort">src/main.c</a><br>

<hr>
<a name="sig_alarm"><b>sig_alarm</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void sig_alarm(int <i>signum</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/timers.c.html#sig_alarm">src/timers.c</a><br>

<hr>
<a name="sig_child"><b>sig_child</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static RETSIGTYPE sig_child(int <i>sig</i>)
</pre>
<font color=blue>Comments</font>: Upon receipt of a <code>SIGCHLD</code>, this
function will first block <code>SIGTERM</code> (see
<a href="#install_signal_handlers"><code>install_signal_handlers()</code></a>
for an explanation for this), then calls <code>waitpid(2)</code> repeatedly,
until there are no child process PIDs to be reaped.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/main.c.html#sig_child">src/main.c</a><br>

<hr>
<a name="sig_debug"><b>sig_debug</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static RETSIGTYPE sig_debug(int <i>sig</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/main.c.html#sig_debug">src/main.c</a><br>

<hr>
<a name="sig_disconnect"><b>sig_disconnect</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static RETSIGTYPE sig_disconnect(int <i>sig</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/main.c.html#sig_disconnect">src/main.c</a><br>

<hr>
<a name="sig_rehash"><b>sig_rehash</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static RETSIGTYPE sig_rehash(int <i>sig</i>)
</pre>
<font color=blue>Comments</font>:  This is the signal handler for the
<code>SIGHUP</code> signal, usually sent to the master daemon PID (sending
<code>SIGHUP</code> to children PIDs can cause trouble).  The signal causes
the server to re-parse the configuration files, and is propagated to all
children by the master daemon.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/main.c.html#sig_rehash">src/main.c</a><br>

<hr>
<a name="sig_terminate"><b>sig_terminate</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static RETSIGTYPE sig_terminate(int <i>sig</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/main.c.html#sig_terminate">src/main.c</a><br>

<hr>
<a name="site_chgrp"><b>site_chgrp</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET site_chgrp(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_site.c.html#site_chgrp">modules/mod_site.c</a><br>

<hr>
<a name="site_chmod"><b>site_chmod</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET site_chmod(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_site.c.html#site_chmod">modules/mod_site.c</a><br>

<hr>
<a name="site_cmd"><b>site_cmd</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET site_cmd(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Command handler for the <code>SITE</code>
FTP comand.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_site.c.html#site_cmd">modules/mod_core.c</a><br>

<hr>
<a name="site_dispatch"><b>site_dispatch</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  modret_t *site_dispatch(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_site.c.html#site_dispatch">modules/mod_site.c</a><br>

<hr>
<a name="site_help"><b>site_help</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET site_help(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_site.c.html#site_help">modules/mod_site.c</a><br>

<hr>
<a name="site_post_cmd"><b>site_post_cmd</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET site_post_cmd(cmd_rec *<i>cmd</i>)
</pre>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_site.c.html#site_post_cmd">modules/mod_site.c</a><br>

<hr>
<a name="site_pre_cmd"><b>site_pre_cmd</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET site_pre_cmd(cmd_rec *<i>cmd</i>)
</pre>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_site.c.html#site_pre_cmd">modules/mod_site.c</a><br>

<hr>
<a name="sleep_cb"><b>sleep_cb</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int sleep_cb(CALLBACK_FRAME)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/timers.c.html#sleep_cb">src/timers.c</a><br>

<hr>
<a name="sortfiles"><b>sortfiles</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void sortfiles(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_ls.c.html#sortfiles">modules/mod_ls.c</a><br>

<hr>
<a name="sreaddir"><b>sreaddir</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  char **sreaddir(pool *<i>workp</i>, const char *<i>dirname</i>, const int <i>sort</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_ls.c.html#sreaddir">modules/mod_ls.c</a><br>

<hr>
<a name="sreplace"><b>sreplace</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  char *sreplace(pool *<i>p</i>, char *<i>s</i>, ...)
</pre>
<font color=blue>Comments</font>: Provides string replacement, substituting a
given substring in <i>s</i> with the provided replacement.  After the <i>s</i>
argument, function arguments should be in <i>substr, replacement</i> pairs.
For example, given a string <code>&quot;Hello, %u&quot;</code>, this function
is used to replace the <code>&quot;%u&quot;</code> with the current user
like so:
<pre>
  newstr = sreplace(p, oldstr, "%u", session.user, NULL);
</pre>
Multiple such <i>substr, replacement</i> pairs can be given in the same call.
<br>
<br>
<font color=blue>Notes</font>: As with many varargs functions, it is
<b>imperative</b> that the last argument to this function be <code>NULL</code>.
You have been warned.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/support.c.html#sreplace">src/support.c</a><br>

<hr>
<a name="sstrcat"><b>sstrcat</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  char *sstrcat(char *<i>dest</i>, const char *<i>src</i>, size_t <i>n</i>)
</pre>
<font color=blue>Comments</font>: This function provides a &quot;safe&quot;
version of <code>strcat()</code>, saving room for a <code>\0</code> at the
end of <i>dest</i> and refusing to concatenate more than <i>n</i> bytes.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/support.c.html#sstrcat">src/support.c</a><br>

<hr>
<a name="sstrncpy"><b>sstrncpy</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  char *sstrncpy(char *<i>dest</i>, const char *<i>src</i>, size_t <i>n</i>)
</pre>
<font color=blue>Comments</font>: This function provides a &quot;safe&quot;
version of <code>strncpy()</code>, saving room for a <code>\0</code> at the
end of <i>dest</i> and refusing to copy more than <i>n</i> bytes.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/support.c.html#sstrncpy">src/support.c</a><br>

<hr>
<a name="stalled_timeout_cb"><b>stalled_timeout_cb</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int stalled_timeout_cb(CALLBACK_FRAME)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/data.c.html#stalled_timeout_cb">src/data.c</a><br>

<hr>
<a name="standalone_main"><b>standalone_main</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void standalone_main(void)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/main.c.html#standalone_main">src/main.c</a><br>

<hr>
<a name="start_ifdefine"><b>start_ifdefine</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET start_ifdefine(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>&lt;IfDefine&gt;</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#start_ifdefine">modules/mod_core.c</a><br>

<hr>
<a name="start_ifmodule"><b>start_ifmodule</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET start_ifmodule(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Configuration directive handler for the
<code>&lt;IfModule&gt;</code> directive.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_core.c.html#start_ifmodule">modules/mod_core.c</a><br>

<hr>
<a name="start_new_server"><b>start_new_server</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  server_rec *start_new_server(const char *<i>addr</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#start_new_server">src/dirtree.c</a><br>

<hr>
<a name="start_sub_config"><b>start_sub_config</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  config_rec *start_sub_config(const char *<i>name</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#start_sub_config">src/dirtree.c</a><br>

<hr>
<a name="std_chdir"><b>std_chdir</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int std_chdir(fsdir_t *<i>f</i>, const char *<i>path</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#std_chdir">src/fs.c</a><br>

<hr>
<a name="std_chmod"><b>std_chmod</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int std_chmod(fsdir_t *<i>f</i>, const char *<i>path</i>, mode_t <i>mode</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#std_chmod">src/fs.c</a><br>

<hr>
<a name="std_chown"><b>std_chown</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int std_chown(fsdir_t *<i>f</i>, const char *<i>path</i>, uid_t <i>uid</i>, gid_t <i>gid</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#std_chown">src/fs.c</a><br>

<hr>
<a name="std_close"><b>std_close</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int std_close(fsdir_t *<i>f</i>, int <i>fd</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#std_close">src/fs.c</a><br>

<hr>
<a name="std_closedir"><b>std_closedir</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int std_closedir(fsdir_t *<i>f</i>, void *<i>dir</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#std_closedir">src/fs.c</a><br>

<hr>
<a name="std_creat"><b>std_creat</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int std_creat(fsdir_t *<i>f</i>, const char *<i>path</i>, mode_t <i>mode</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#std_creat">src/fs.c</a><br>

<hr>
<a name="std_link"><b>std_link</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int std_link(fsdir_t *<i>f</i>, const char *<i>path1</i>, const char *<i>path2</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#std_link">src/fs.c</a><br>

<hr>
<a name="std_lseek"><b>std_lseek</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static off_t std_lseek(fsdir_t *<i>f</i>, int <i>fd</i>, off_t <i>offset</i>, int <i>whence</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#std_lseek">src/fs.c</a><br>

<hr>
<a name="std_lstat"><b>std_lstat</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int std_lstat(fsdir_t *<i>f</i>, const char *<i>path</i>, struct stat *<i>sbuf</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#std_lstat">src/fs.c</a><br>

<hr>
<a name="std_open"><b>std_open</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int std_open(fsdir_t *<i>f</i>, const char *<i>path</i>, int <i>access</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#std_open">src/fs.c</a><br>

<hr>
<a name="std_opendir"><b>std_opendir</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static void *std_opendir(fsdir_t *<i>f</i>, const char *<i>path</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#std_opendir">src/fs.c</a><br>

<hr>
<a name="std_read"><b>std_read</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int std_read(fsdir_t *<i>f</i>, int <i>fd</i>, char *<i>buf</i>, size_t <i>size</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#std_read">src/fs.c</a><br>

<hr>
<a name="std_readdir"><b>std_readdir</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static struct dirent *std_readdir(fsdir_t *<i>f</i>, void *<i>dir</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#std_readdir">src/fs.c</a><br>

<hr>
<a name="std_readlink"><b>std_readlink</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int std_readlink(fsdir_t *<i>f</i>, const char *<i>path</i>, char *<i>buf</i>, size_t <i>max</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#std_readlink">src/fs.c</a><br>

<hr>
<a name="std_rename"><b>std_rename</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int std_rename(fsdir_t *<i>f</i>, const char *<i>ren_from</i>, const char *<i>ren_to</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#std_rename">src/fs.c</a><br>

<hr>
<a name="std_stat"><b>std_stat</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int std_stat(fsdir_t *<i>f</i>, const char *<i>path</i>, struct stat *<i>sbuf</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#std_stat">src/fs.c</a><br>

<hr>
<a name="std_symlink"><b>std_symlink</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int std_symlink(fsdir_t *<i>f</i>, const char *<i>path1</i>, const char *<i>path2</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#std_symlink">src/fs.c</a><br>

<hr>
<a name="std_unlink"><b>std_unlink</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int std_unlink(fsdir_t *<i>f</i>, const char *<i>path</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#std_unlink">src/fs.c</a><br>

<hr>
<a name="std_write"><b>std_write</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int std_write(fsdir_t *<i>f</i>, int <i>fd</i>, const char *<i>buf</i>, size_t <i>size</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/fs.c.html#std_write">src/fs.c</a><br>

<hr>
<a name="stor_abort"><b>stor_abort</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static void stor_abort(void)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_xfer.c.html#stor_abort">modules/mod_xfer.c</a><br>

<hr>
<a name="stor_complete"><b>stor_complete</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static void stor_complete(void)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_xfer.c.html#stor_complete">modules/mod_xfer.c</a><br>

<hr>
<a name="strip_end"><b>strip_end</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  char *strip_end(char *<i>s</i>, char *<i>ch</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/support.c.html#strip_end">src/support.c</a><br>

<hr>
<a name="strsep"><b>strsep</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  char *strsep(char **<i>stringp</i>, const char *<i>delim</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/lib/strsep.c.html#strsep">lib/strsep.c</a><br>

<hr>
<a name="supp_getgrent"><b>supp_getgrent</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static struct group *supp_getgrent(const char *<i>buf</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/lib/pwgrent.c.html#supp_getgrent">lib/pwgrent.c</a><br>

<hr>
<a name="supp_getpwent"><b>supp_getpwent</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static struct passwd *supp_getpwent(const char *<i>buf</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/lib/pwgrent.c.html#supp_getpwent">lib/pwgrent.c</a><br>

<hr>
<a name="supp_grplist"><b>supp_grplist</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static char **supp_grplist(char *<i>s</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/lib/pwgrent.c.html#supp_grplist">lib/pwgrent.c</a><br>

<hr>
<a name="timer_cmp"><b>timer_cmp</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int timer_cmp(timer_t *<i>t1</i>, timer_t *<i>t2</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/timers.c.html#timer_cmp">src/timers.c</a><br>

<hr>
<a name="timer_sleep"><b>timer_sleep</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int timer_sleep(int <i>seconds</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/timers.c.html#timer_sleep">src/timers.c</a><br>

<hr>
<a name="unblock_alarms"><b>unblock_alarms</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void unblock_alarms(void)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/utils.c.html#unblock_alarms">src/utils.c</a><br>

<hr>
<a name="unblock_signals"><b>unblock_signals</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void unblock_signals(void)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/support.c.html#unblock_signals">src/support.c</a><br>

<hr>
<a name="unixpw_init"><b>unixpw_init</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int unixpw_init(void)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_unixpw.c.html#unixpw_init">modules/mod_unixpw.c</a><br>

<hr>
<a name="unixpw_sess_init"><b>unixpw_sess_init</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int unixpw_sess_init(void)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_unixpw.c.html#unixpw_sess_init">modules/mod_unixpw.c</a><br>

<hr>
<a name="user_expression"><b>user_expression</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int user_expression(char **<i>expr</i>)
</pre>
<font color=blue>Comments</font>:  Evaluates the given expression <i>expr</i>
as a user <code>AND</code> expression, which means that <i>all</i> user
conditions must match for the current connected user for the expression to be
true.  Returns <code>TRUE</code> if the expression evaluates thus for the
current user, <code>FALSE</code> otherwise.<br>
<br>
<font color=blue>Bugs</font>: This function assumes use of
<code>session.user</code>.  Better would be to evaluate <i>expr</i> against
a caller-provided user name.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/dirtree.c.html#user_expression">src/dirtree.c</a><br>

<hr>
<a name="xaset_copy"><b>xaset_copy</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  xaset_t *xaset_copy(pool *<i>pool</i>, xaset_t *<i>set</i>, size_t <i>msize</i>, XASET_MCOPY <i>copyf</i>)
</pre>
<font color=blue>Comments</font>: Perform an exact copy of the entire set,
returning the new set.  <code>msize</code> specifies the size of each
member.  If <code>copyf</code> is non-<code>NULL</code>, it is called
instead to copy each member.<br>
<br>
Returns <code>NULL</code> if out of memory exception occurs.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/sets.c.html#xaset_copy">src/sets.c</a><br>

<hr>
<a name="xaset_create"><b>xaset_create</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  xaset_t *xaset_create(pool *<i>pool</i>, XASET_COMPARE <i>compf</i>)
</pre>
<font color=blue>Comments</font>: Create a new set.  <i>compf</i> is
a pointer to the function used to compare members of the set.<br>
<br>
Returns <code>1</code>, <code>0</code>, or <code>-1</code> after the
fashion of <code>strcmp</code>.  Returns <code>NULL</code> if memory
allocation fails.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/sets.c.html#xaset_create">src/sets.c</a><br>

<hr>
<a name="xaset_insert"><b>xaset_insert</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int xaset_insert(xaset_t *<i>set</i>, xasetmember_t *<i>member</i>)
</pre>
<font color=blue>Comments</font>: Inserts a new member into an existing
set.  The member is inserted at the beginning of the list.<br>
<br>
Returns <code>1</code> if successful, <code>0</code> if one or more arguments
are invalid or something is wrong with the set, <code>-1</code> if there's
an error (not used).<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/sets.c.html#xaset_insert">src/sets.c</a><br>

<hr>
<a name="xaset_insert_end"><b>xaset_insert_end</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int xaset_insert_end(xaset_t *<i>set</i>, xasetmember_t *<i>member</i>)
</pre>
<font color=blue>Comments</font>: Inserts a new <code>xasetmember_t</code>
<i>member</i> into an existing set at the end of the list.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/sets.c.html#xaset_insert_end">src/sets.c</a><br>

<hr>
<a name="xaset_insert_sort"><b>xaset_insert_sort</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int xaset_insert_sort(xaset_t *<i>set</i>, xasetmember_t *<i>member</i>, int <i>dupes_allowed</i>)
</pre>
<font color=blue>Comments</font>: Inserts a new member into an existing
set <i>set</i>, sorted using the set's comparison callback function.<br>
<br>
If <i>dupes_allowed</i> is non-zero, returns <code>0</code> and the
member is not added to the set.  Otherwise, it is added immediately before
the first duplicate.  If the set is not empty and not presorted, results
are undefined.<br>
<br>
Returns <code>1</code> if successful, <code>0</code> if there are bad
arguments or if it is a duplicate member, <code>-1</code> if there is an error
(not used, but an applicable error would be <code>errno</code>).<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/sets.c.html#xaset_insert_sort">src/sets.c</a><br>

<hr>
<a name="xaset_remove"><b>xaset_remove</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  int xaset_remove(xaset_t *<i>set</i>, xasetmember_t *<i>member</i>)
</pre>
<font color=blue>Comments</font>: Remove a member from a set.  The set need
not be sorted.  Note that this does <b>NOT</b> free the memory used by
the removed member.  No check is performed to validate that the <i>member</i>
is truly a member of <i>set</i>.<br>
<br>
Returns <code>1</code> if successful, <code>0</code> if the arguments are
invalid, <code>-1</code> if there's an error (check <code>errno</code>, unused
at this time).<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/sets.c.html#xaset_remove">src/sets.c</a><br>

<hr>
<a name="xaset_subtract"><b>xaset_subtract</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  xaset_t *xaset_subtract(pool *<i>pool</i>, xaset_t *<i>set1</i>, xaset_t *<i>set2</i>, size_t <i>msize</i>,
    XASET_MCOPY <i>copyf</i>)
</pre>
<font color=blue>Comments</font>: Perform set subtraction:
<i>set1 - set2</i>, creating a new set composed of all the elements
in <i>set1</i> that are not in <i>set2</i>.  <code>NULL</code>
is returned if a new set cannot be created (out of memory), or either
<i>set1</i> or <i>set2</i> are <code>NULL</code>.  If
<i>copyf</i> is non-<code>NULL</code>, it is used to copy each
applicable element to the new set.  If either of the two sets is unsorted,
the result will be undefined.  <i>set1</i>'s comparison callback
function is used when comparing members of each set.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/sets.c.html#xaset_subtract">src/sets.c</a><br>

<hr>
<a name="xaset_union"><b>xaset_union</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  xaset_t *xaset_union(pool *<i>pool</i>, xaset_t *<i>set1</i>, xaset_t *<i>set2</i>, size_t <i>msize</i>,
    XASET_MCOPY <i>copyf</i>) 
</pre>
<font color=blue>Comments</font>: Perform a set union.  The two sets do not
need to be sorted, however the returned set will be.  Duplicate entries
are, as per normal set logic, removed.<br>
<br>
The return value is the new set, or <code>NULL</code> if out of memory,
or one or more of the arguments are invalid.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/src/sets.c.html#xaset_union">src/sets.c</a><br>

<hr>
<a name="xfer_abor"><b>xfer_abor</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET xfer_abor(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Command handler for the <code>ABOR</code>
FTP command.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_xfer.c.html#xfer_abor">modules/mod_xfer.c</a><br>

<hr>
<a name="xfer_allo"><b>xfer_allo</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET xfer_allo(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Command handler for the <code>ALLO</code>
FTP command.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_xfer.c.html#xfer_allo">modules/mod_xfer.c</a><br>

<hr>
<a name="xfer_err_cleanup"><b>xfer_err_cleanup</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET xfer_err_cleanup(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_xfer.c.html#xfer_err_cleanup">modules/mod_xfer.c</a><br>

<hr>
<a name="xfer_exit_cb"><b>xfer_exit_cb</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static void xfer_exit_cb(void)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_xfer.c.html#xfer_exit_cb">modules/mod_xfer.c</a><br>

<hr>
<a name="xfer_log_retr"><b>xfer_log_retr</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET xfer_log_retr(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_xfer.c.html#xfer_log_retr">modules/mod_xfer.c</a><br>

<hr>
<a name="xfer_log_stor"><b>xfer_log_stor</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET xfer_log_stor(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_xfer.c.html#xfer_log_stor">modules/mod_xfer.c</a><br>

<hr>
<a name="xfer_mode"><b>xfer_mode</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET xfer_mode(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Command handler for the <code>MODE</code>
FTP command.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_xfer.c.html#xfer_mode">modules/mod_xfer.c</a><br>

<hr>
<a name="xfer_post_stou"><b>xfer_post_stou</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET xfer_post_stou(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_xfer.c.html#xfer_post_stou">modules/mod_xfer.c</a><br>

<hr>
<a name="xfer_pre_appe"><b>xfer_pre_appe</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET xfer_pre_appe(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_xfer.c.html#xfer_pre_appe">modules/mod_xfer.c</a><br>

<hr>
<a name="xfer_pre_retr"><b>xfer_pre_retr</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET xfer_pre_retr(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_xfer.c.html#xfer_pre_retr">modules/mod_xfer.c</a><br>

<hr>
<a name="xfer_pre_stor"><b>xfer_pre_stor</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET xfer_pre_stor(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_xfer.c.html#xfer_pre_stor">modules/mod_xfer.c</a><br>

<hr>
<a name="xfer_pre_stou"><b>xfer_pre_stou</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET xfer_pre_stou(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_xfer.c.html#xfer_pre_stou">modules/mod_xfer.c</a><br>

<hr>
<a name="xfer_rest"><b>xfer_rest</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET xfer_rest(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Command handler for the <code>REST</code>
FTP command.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_xfer.c.html#xfer_rest">modules/mod_xfer.c</a><br>

<hr>
<a name="xfer_retr"><b>xfer_retr</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET xfer_retr(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Command handler for the <code>RETR</code>
FTP command.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_xfer.c.html#xfer_retr">modules/mod_xfer.c</a><br>

<hr>
<a name="xfer_sess_init"><b>xfer_sess_init</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  static int xfer_sess_init(void)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_xfer.c.html#xfer_sess_init">modules/mod_xfer.c</a><br>

<hr>
<a name="xfer_smnt"><b>xfer_smnt</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET xfer_smnt(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Command handler for the <code>SMNT</code>
FTP command.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_xfer.c.html#xfer_smnt">modules/mod_xfer.c</a><br>

<hr>
<a name="xfer_stor"><b>xfer_stor</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET xfer_stor(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Command handler for the <code>STOR</code>
FTP command.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_xfer.c.html#xfer_stor">modules/mod_xfer.c</a><br>

<hr>
<a name="xfer_stru"><b>xfer_stru</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET xfer_stru(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Command handler for the <code>STRU</code>
FTP command.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_xfer.c.html#xfer_stru">modules/mod_xfer.c</a><br>

<hr>
<a name="xfer_type"><b>xfer_type</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  MODRET xfer_type(cmd_rec *<i>cmd</i>)
</pre>
<font color=blue>Comments</font>: Command handler for the <code>TYPE</code>
FTP command.<br>
<br>
<font color=blue>Source File</font>:
  <a href="../src/modules/mod_xfer.c.html#xfer_type">modules/mod_xfer.c</a><br>

<hr>
<a name="xmalloc"><b>xmalloc</b><br>
<br>
<font color=blue>Declaration</font>:<br>
<pre>
  void *xmalloc(size_t <i>size</i>)
</pre>
<font color=blue>Source File</font>:
  <a href="../src/src/pool.c.html#xmalloc">src/pool.c</a><br>

<hr><br>

Author: <i>$Author$</i><br>
Last Updated: <i>$Date$</i><br>

<br><hr>

<font size=2><b><i>
&copy; Copyright 2000-2003 TJ Saunders<br>
 All Rights Reserved<br>
</i></b></font>

<hr><br>

</body>
</html>
