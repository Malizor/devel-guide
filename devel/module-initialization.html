<!-- $Id$ -->
<!-- $Source$ -->

<html>
<head>
<title>ProFTPD Developer's Guide: Initializing a Module</title>
</head>

<body bgcolor=white>

<hr><br>
<center>
<img src="../images/proftpd.png" border=0>
<br><br>
<h3><b>ProFTPD Developer's Guide: Initializing a Module</b></h3>
<i><b>ProFTPD Version 1.2</b></i><br>
</center>
<hr><br>

<p>
<center><a href="../toc.html">Table of Contents</a></center><br>

<p>
There are two main points when a module can be <i>initialized</i>: during
daemon startup, and prior to handling an FTP session.  In order to tell
the core engine that your module has code to be run at these points, you
need to use the initialization callback slots in the <code>module</code>
structure at the bottom of your module source file:
<pre>
  module geewhiz_module = {
    ...

    <font color=green>/* Module initialization function */</font>
    NULL,

    <font color=green>/* Session initialization function */</font>
    NULL
  }
</pre>
Rather than having <code>NULL</code>, you would have the name of your 
initialization callback function there.  Both initialization callback
functions have the same prototype:
<pre>
  int <i>func</i>(void);
</pre>

<p>
What is the difference, then, between module initialization and session
initialization?  The former is called when the <code>proftpd</code> daemon
starts, prior to parsing the configuration file; the latter is called
after the daemon has <code>fork()</code>ed a process to handle a client,
but before the process handles any FTP commands sent by the client.
Module initialization, if any is needed, tends to be simple: allocating
module-specific resources (<i>e.g.</i> memory <code>pool</code>,
<code>array_header</code>s), perhaps initializing any third-party code
(<i>e.g.</i> libraries) used by the module, <i>etc</i>.  Most modules will
make use more of the session initialization function, which is where the
module can act on per-server/server-specific configuration settings, such
as processing any of the module's configuration directives that are in
context of the server contacted by the client.

<p>
The two above callbacks suffice for the majority of situations in which a
module developer might want to have initialization code executed.  However,
every now and then, there arises the case where a module may need to be
initialized <i>based on configured directives</code>, but still as part
of the daemon startup process.  Remember, the module initialization callback
is called <b>before</b> the configuration file is parsed, not after.  To
handle this scenario, a new registration function was added in 1.2.8rc1:
<pre>
  void pr_register_postparse_init(int (<i>*cb</i>)(void));
</pre>
If a module wishes to have initialization code executed after the configuration
file has been parsed, then, in the module's module initialization function,
it will need to call <code>pr_register_postparse_init()</code>, specifying
the name of the function to be called once the daemon has parsed the
configuration.

<p>
For example:
<pre>
  static int geewhiz_postparse_cb(void) {
    <font color=green>/* Do some possibly-configuration-influenced stuff here */</font>
    ...

    return 0;
  }

  static int geewhiz_init(void) {
    ...

    <font color=green>/* Make sure we act on the needed directives' parameters */</font>
    pr_register_postparse_init(geewhiz_postparse_cb);

    return 0;
  }

  module geewhiz_module = {
    ...

    <font color=green>/* Module initialization function */</font>
    geewhiz_init,

    <font color=green>/* Session initialization function */</font>
    NULL
  }
</pre>

<p>
<center><a href="../toc.html">Table of Contents</a></center><br>

<hr><br>

Author: <i>$Author$</i><br>
Last Updated: <i>$Date$</i><br>

<br><hr>

<font size=2><b><i>
&copy; Copyright 2000-2003 TJ Saunders<br>
 All Rights Reserved<br>
</i></b></font>

<hr><br>

</body>
</html>
