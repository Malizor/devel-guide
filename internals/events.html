<!-- $Id$ -->
<!-- $Source$ -->

<html>
<head>
<title>ProFTPD Developer's Guide: Events</title>
</head>

<body bgcolor=white>

<hr><br>
<center>
<img src="../images/proftpd.png" border=0>
<br><br>
<h3><b>ProFTPD Developer's Guide: Events</b></h3>
<i><b>ProFTPD Version 1.2</b></i><br>
</center>
<hr><br>

<p>
<center><a href="../toc.html">Table of Contents</a></center><br>

<p>
<b>What <code>Events</code> Are</b><br>
Events are an intraprocess notification system, used to indicate certain
conditions to other parts of the code that has registered an interest
in these conditions.  A module can register a callback for any given
event; when that event is generated, the callback is invoked.  All registered
callbacks, or <i>listeners</i>, are invoked in the usual module load order.

<p>
The Events API replaces the old registration functions that were specifically
for process exits, daemon startup, and configuration parsing.  That old
system would not scale well, as several new functions would need to be
added to the core API for every new event handled.  The new Events API can
handle any number of arbitrary events; modules can easily generate their
own custom events without requiring code changes in the core code.

<p>
<b>When <i>Not</i> To Use <code>Events</code></b><br>
The ProFTPD API contains many hooks and entry points into the lifecycle
of an FTP session: authentication handlers, command handlers, configuration
directive handlers, filesystem and network callbacks, <i>etc</i>.  These APIs
cover most of the situations in which a module developer is interested.
Events are <i>not</i> needed in cases where the existing API can be used
to achieve the same goal.

<p>
<b><code>Event</code> List</b><br>
Some of the current <code>Events</code></b> generated by
<code>proftpd</code> are:<br>
<ul>
  <li><em>core.create-home</em><br>
    Generated when the <code>CreateHome</code> directive is used, and
    a home directory is actually being created for the user who is
    authenticating.  The name of the user whose home is being created is
    sent as the <i>event_data</i>.
  </li>

  <p>
  <li><em>core.exit</em><br>
    Generated when the process (both session and daemon) exits.  The daemon
    exit listener will run with root privileges.  This event replaces the old
    exit handlers registered via <code>pr_exit_register_handler()</code>,
    which is now deprecated.

    <p>
    <b><i>Note:</i></b> if a handler for this event is registered in a
    module initialization function, then that handler will receive the
    event when the daemon (not a session) shuts down.  If a handler for this
    event is registered in a session initialization function, that handler will
    receive the event when the session exits.  The same handler can be used
    for both types of exit.  If you wish to have separate listeners to
    handle daemon exits differently from session exits, register one listener
    during module initialization, then during session initialization,
    unregister that first listener and register the listener for session
    exits.

    <p>
    Exit handlers, as mentioned, are run as part of the exit process, which is
    executed according to various conditions: an ACL denies access to the
    client, a <code>MaxClients</code> or related limit is reached, the session
    times out, the client issued a <code>QUIT</code> command, <i>etc</i>.  For
    whatever reasons, the session process will decide to end the session, and
    will call <a href="../src/src/main.c.html#end_login"><code>end_login()</code></a>.
    The <code>end_login()</code> function calls <code>end_login_noexit()</code>,
    which deletes the session entry from the scoreboard, calls all registered
    exit handlers, cleans up the <code>wtmp</code> log, and closes any
    lingering network connections. Then <code>end_login()</code> actually
    causes the process to end, via the <code>_exit(2)</code> system call.

    <p>
    <b><i>Do not</i></b> re-register listeners for <code>core.exit</code>;
    register them only <i>once</i>, during module/session initialization.
    Mulitple registration will cause the callback to be executed multiple
    times, which is probably not what is intended.  Also, take care when
    writing exit handlers.  The handler should not <b>assume</b> anything
    about the state of pointers or variables: check that pointers are not
    <code>NULL</code> before dereferencing them, that values are within
    acceptable ranges before operating on them, <i>etc</i>.  Failure to do so
    will cause your exit handler to segfault.
  </li>

  <p>
  <li><em>core.max-connection-rate</em><br>
    Generated when the <code>MaxConnectionRate</code> limit, if present, is
    reached.
  </li>

  <p>
  <li><em>core.max-instances</em><br>
    Generated when the <code>MaxInstances</code> limit, if present, is reached.
  </li>

  <p>
  <li><em>core.module-load</em><br>
    Generated after a module is loaded.  The <code>event_data</code> for
    this event is a <code>const char *</code> of the name of the module
    that was loaded, <i>e.g.</i> <code>mod_example.c</code>.
  </li>

  <p>
  <li><em>core.module-unload</em><br>
    Generated before a module is unloaded.  The <code>event_data</code> for
    this event is a <code>const char *</code> of the name of the module
    being unloaded, <i>e.g.</i> <code>mod_example.c</code>.
  </li>

  <p>
  <li><em>core.preparse</em><br>
    Generated just before the core engine parses the configuration file(s).

    <p>
    <b><i>Note:</i></b> a handler for this event <b>must</b> be registered in a
    module initialization function (<b>not</b> in a session initialization
    function), for the event is generated before starting any sessions.
  </li>

  <p>
  <li><em>core.postparse</em><br>
    Generated just after the core engine parses the configuration file(s).

    <p>
    <b><i>Note:</i></b> a handler for this event <b>must</b> be registered in a
    module initialization function (<b>not</b> in a session initialization
    function), for the event is generated before starting any sessions.
  </li>

  <p>
  <li><em>core.restart</em><br>
    Generated just before the core engine processes the <code>SIGHUP</code>
    signal.  This event replaces the old rehash handlers registered via
    <code>pr_rehash_register_handler()</code>, which is now deprecated.

    <p>
    There are some tasks that should be done every time the daemon is
    restarted via the <code>SIGHUP</code> signal, tasks such as destroying
    and reallocating a module-specific <code>pool</code>, or
    &quot;bouncing&quot; any open file descriptors (<i>e.g.</i> for log files)
    by closing and reopening them, <i>etc</i>.  This process of restarting the
    daemon is called <i>rehashing</i> in the code.

    <p>
    <b><i>Do not</i></b> re-register <code>core.restart</code> handlers;
    register them only once, during module initialization.  Otherwise, you
    will bloat up the memory usage of the daemon process, every time it is
    restarted.
  </li>

  <p>
  <li><em>core.startup</em><br>
    Generated by the core engine after it has &quot;daemonized&quot;.

    <p>
    <b><i>Note:</i></b> a handler for this event <b>must</b> be registered in a
    module initialization function (<b>not</b> in a session initialization
    function), for the event is generated before starting any sessions.
  </li>

  <p>
  <li><em>mod_auth.anon-reject-passwords</em><br>
    Generated by the <code>mod_auth</code> module when the
    <code>AnonRejectPasswords</code> limit, if present, is reached.
  </li>

  <p>
  <li><em>mod_auth.max-clients</em><br>
    Generated by the <code>mod_auth</code> module when the
    <code>MaxClients</code> limit, if present, is reached.
  </li>

  <p>
  <li><em>mod_auth.max-clients-per-class</em><br>
    Generated by the <code>mod_auth</code> module when the
    <code>MaxClientsPerClass</code> limit, if present, is reached.
  </li>

  <p>
  <li><em>mod_auth.max-clients-per-host</em><br>
    Generated by the <code>mod_auth</code> module when the
    <code>MaxClientsPerHost</code> limit, if present, is reached.
  </li>

  <p>
  <li><em>mod_auth.max-clients-per-user</em><br>
    Generated by the <code>mod_auth</code> module when the
    <code>MaxClientsPerUser</code> limit, if present, is reached.
  </li>

  <p>
  <li><em>mod_auth.max-hosts-per-user</em><br>
    Generated by the <code>mod_auth</code> module when the
    <code>MaxHostsPerUser</code> limit, if present, is reached.
  </li>

  <p>
  <li><em>mod_auth.max-login-attempts</em><br>
    Generated by the <code>mod_auth</code> when the
    <code>MaxLoginAttempts</code> limit, if present, is reached.
  </li>
</ul>

<p>
Note that if a non-<code>NULL void *user_data</code> pointer is provided when
registering an event handler, and that pointer is allocated from a pool
that does not survive a restart, then the caller should unregister that
event handler during a restart, and re-register the handler again with
an updated pointer.  The problem is that the Events API keeps a pointer
to the given <code>user_data</code>, and when the pool from which that
data is destroyed, the pointer becomes invalid.  The invalid pointer would
be passed to the event handler, after a restart, unless the pointer is
properly replaced via re-registration.

<p>
<b>Code Example</b><br>
<pre>
  <font color=green>/* Event handler for the 'mod_foo.foo' event. */</font>
  static void my_foo_ev(const void *event_data, void *user_data) {
    (void) pr_log_writefile(my_logfd, MOD_MY_VERSION, "the 'mod_foo.foo' event occurred");
    return;
  }

  ...

    <font color=green>/* Register our callback for the 'mod_foo.foo' event.
     * The last NULL argument indicates that we are not interested in passing our
     * own "user_data" parameter to the callback.
     */</font>
    pr_event_register(&my_module, "mod_foo.foo", my_foo_ev, NULL);

  ...

    <font color=green>/* Meanwhile, back in mod_foo.c's handlers...*/</font>
    pr_event_generate("mod_foo.foo", NULL);
</pre>
That's it.  Events can be generated for which there are no listeners
registered, and listeners can be registered for events which are never
generated.

<p>
<center><a href="../toc.html">Table of Contents</a></center><br>

<hr><br>

Author: <i>$Author$</i><br>
Last Updated: <i>$Date$</i><br>

<br><hr>

<font size=2><b><i>
&copy; Copyright 2000-2004 TJ Saunders<br>
 All Rights Reserved<br>
</i></b></font>

<hr><br>

</body>
</html>
