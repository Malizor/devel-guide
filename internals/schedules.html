<!-- $Id$ -->
<!-- $Source$ -->

<html>
<head>
<title>ProFTPD Developer's Guide: Schedules</title>
</head>

<body bgcolor=white>

<hr><br>
<center>
<img src="../images/proftpd.png">
<br><br>
<h3><b>ProFTPD Developer's Guide: Schedules</b></h3>
<i><b>ProFTPD Version 1.2</b></i><br>
</center>
<hr><br>

<p>
<center><a href="../toc.html">Table of Contents</a></center><br>

<p>
<b>Schedules</b><br>
The core engine provides a mechanism for setting schedules, which can be used
to perform actions on a recurring basis.  The triggering of schedules is
based on &quot;loops&quot;, the number of times the daemon loops around while
waiting for incoming connections.  This means that schedules, rather than
being based on a clock, are based on server activity: a busy server loops
more quickly than a quiescent one.

<pp>
The main functions to use when dealing with schedules are defined in
<a href="../src/include/support.h.html#schedule"><code>support.h</code></a>:
<pre>
  void schedule(void <i>(*f)(void *, void *, void *, void *)</i>, int <i>nloops</i>, void *a1, void *a2,
    void *a3, void *a4)
  void run_schedule()
</pre>

<p>
The <code>schedule()</code> function (which would ideally be named
<code>add_schedule()</code>) registers a schedule callback function
<i>f</i>, which handles four <code>void *</code> arguments, to be run every
<i>nloops</i>.  When the called, <i>f</i> will be passed the registered
pointers <i>a1</i> through <i>a4</i>.

<p>
The <code>run_schedule()</code> function (which would ideally be named
<code>run_schedule<i>s</i>()</code>) is called by the internal engine, and
should not be invoked anywhere else in the code without a very good reason.

<p>
<b>Example Schedule Callback</b><br>
An excerpt from
<a href="../src/src/main.c.html#sig_rehash"><code>main.c</code></a>, this
defines the schedule callback for rehashing -- the registration of this
schedule occurs in the <code>SIGHUP</code> signal handler,
<a href="../src/src/main.c.html#sig_rehash"><code>sig_rehash()</code></a>:
<pre>
static RETSIGTYPE sig_rehash(int sig)
{
  schedule(main_rehash,0,NULL,NULL,NULL,NULL);

  signal(SIGHUP,sig_rehash);
}
</pre>

And here one see how the rehashing of the configuration file, signalled via
<code>SIGHUP</code>, is scheduled:
<pre>
void main_rehash(void *d1, void *d2, void *d3, void *d4)
{
  <font color=blue>/* rehashing code here */</font>
  ...

  return;
}
</pre>

<p>
In this example, the <i>nloops</code> value given, <code>0</code>, means that
that schedule will be run the next time <code>run_schedule()</code> is called.
The <i>nloops</i> value is used to determine the frequency with which a 
schedule fires, assuming it is meant to be a recurring schedule.  Which
brings up a good point: schedules inherently are one-time triggers.  They
fire, then are removed from the list of impending schedules.  Unlike
<a href="timers.html">timers</a>, schedules cannot re-register themselves
simply by returning a certain value.  Instead, if a recurring schedule is
desired, simply have the callback function call <code>schedule()</code> again
to add that callback back to the schedule list.

<p>
<b>How Schedules Work</b><br>
The schedule mechanism is based on counters associated with each schedule
object, the <i>nloops</i> member.  At certain points in the code, those
counters are decremented.  Once the counter reaches zero, the callback
function for that schedule object is triggered.  Schedule objects are
registered and added to an internally maintained list, and removed from
that list once the callback has triggered. (<i><b>NOTE</b>: the memory
of unregistered schedules is currently not recovered, so be spare in your
use of schedules until this is fixed.  One potential fix would be a
list of recycled schedules, much as there is for timers.</i>)

<p>
The <i>nloops</i> counter is decremented by <code>run_schedule()</code>, which
is invoked at four points in the core:
<ul>
  <li><a href="../src/src/io.c.html#io_poll"><code>io_poll()</code></a>
  <li><a href="../src/src/io.c.html#io_read"><code>io_read()</code></a>
  <li><a href="../src/src/io.c.html#io_write"><code>io_write()</code></a>
  <li><a href="../src/src/main.c.html#server_loop"><code>server_loop()</code></a>
</ul>

<p>
Similar to timers, schedules<b>do not</b> provide fine-grained time resolution, and are not meant for precise work.  In fact, the nature of the loops means
the time at which a schedule is triggered is very coarse.  Schedules are a 
mechanism for scheduling something to happen <i>at some point</i> in the future,
when that activity is not time-critical.  Periodically checking state,
performing scrubbing or cleanup activities -- these are activities suited
for scheduling.

<p>
<center><a href="../toc.html">Table of Contents</a></center><br>

<hr><br>

Author: <i>$Author$</i><br>
Last Updated: <i>$Date$</i><br>

<br><hr>

<font size=2><b><i>
&copy; Copyright 2000-2002 TJ Saunders<br>
 All Rights Reserved<br>
</i></b></font>

<hr><br>

</body>
</html>
