<!-- $Id$ -->
<!-- $Source$ -->

<html>
<head>
<title>ProFTPD Developer's Guide: Timers</title>
</head>

<body bgcolor=white>

<hr><br>
<center>
<img src="../images/proftpd.png" border=0>
<br><br>
<h3><b>ProFTPD Developer's Guide: Timers</b></h3>
<i><b>ProFTPD Version 1.2</b></i><br>
</center>
<hr><br>

<p>
<center><a href="../toc.html">Table of Contents</a></center><br>

<p>
<b>Timers</b><br>
The core code provides a mechanism for setting timers, which can be used
to set time limits on actions, or to perform actions on a recurring basis.
<pp>
The main functions to use when dealing with timers are defined in
<a href="../src/include/timers.h.html"><code>timers.h</code></a>:
<pre>
  int add_timer(int <i>seconds</i>, int <i>timerno</i>, module *<i>mod</i>, callback_t <i>cb</i>);
  int remove_timer(int <i>timerno</i>, module *<i>mod</i>);
  int reset_timer(int <i>timerno</i>, module *<i>mod</i>);
  void pr_alarms_block(void);
  void pr_alarms_unblock(void);
</pre>

<p>
For the <code>add_timer()</code> function, <i>seconds</i> is the length of the
timer, <i>timerno</i> is an arbitrary timer ID, <i>mod</i> is a pointer to the
module registering the timer, and <i>cb</i> is the function to be invoked once
the timer has expired.  If <i>timerno</i> is -1, the timer will be assigned a
&quot;dynamic&quot; timer number greater than 1024.  This &quot;dynamic&quot;
number is not random; rather, it starts at 1024, as is incremented for every
timer created with a <i>timerno</i> of -1.  This function returns the
given <i>timerno</i>, and has no error return value.

<p>
The <code>remove_timer()</code> function does just that, removing every timer
with the given ID <i>timerno</i> registered by module <i>mod</i>.  Note that
for this function, and for <code>reset_timer</code>, the macro
<code>ANY_MODULE</code> may be given for <i>mod</i>, in which case every timer
with the given <i>timerno</i> will be removed.  If a matching timer is found,
it's <i>timerno</i> is returned, otherwise 0 is returned.

<p>
The <code>reset_timer()</code> function is also pretty self-explanatory,
resetting the timer with the given <i>timerno</i> from module <i>mod</i>.
If a matching timer is found, that timer's <i>timerno</i> is returned,
otherwise 0 is returned.

<p>
The <code>pr_alarms_block()</code> function is used to prevent timers from
firing.  Timers that would have fired while blocked are noted, and will be
fired once alarms are unblocked.  This is to be used in critical sections of
code which cannot stand interruption.
<p>
As it notes in the comments in
<a href="../src/src/timers.c.html"><code>timers.c</code></a>, the blocking of
alarms is done manually, rather than via system calls, to allow for easier
signal handling, portability, detection of the number of blocked alarms, and
to allow for nested <code>block</code>/<code>unblock</code> calls.

<p>
The <code>pr_alarms_unblock()</code> function allows alarms to once again be
delivered.  Any pending alarms that should have been delivered while alarms
were blocked are handled.

<p>
<b>Example Timer Callback</b><br>
This excerpt from
<a href="../src/modules/mod_auth.c.html"><code>mod_auth.c</code></a> shows
the <code>TimeoutLogin</code> timer implementation:
<pre>
int login_timeout_cb(CALLBACK_FRAME) {
  <font color=green>/* Is this the proper behavior when timing out? */</font>
  pr_response_send_async(R_421,
                      "Login Timeout (%d seconds): "
                      "closing control connection.",
                      TimeoutLogin);
  
  session_exit(PR_LOG_NOTICE, "FTP login timed out, disconnected.", 0, NULL);
 
  <font color=green>/* Don't restart the timer */</font> 
  return 0;
}
</pre>

<p>
The return value of the timer callback function is critical: if 0 is returned,
the timer is done, and will not fire again.  If non-zero, the timer is
restarted, and will again be invoked once the configured length of time has
passed.

<p>
The <code>CALLBACK_FRAME</code> macro is <code>#define</code>d to be:
<pre>
  #define CALLBACK_FRAME          LPARAM p1,LPARAM p2,LPARAM p3,void *data
</pre>
where <code>LPARAM</code> is <code>typedef</code>d to be:
<pre>
  typedef unsigned long LPARAM;
</pre>

<p>
Ostensibly, <code>LPARAM</code> is the way it is because it is the &quot;
longest bitsize compatible with a scalar and largest pointer&quot;.  However,
it does evoke compiler warnings if pointers and data are passed this way.

<p>
Another thing of which to be aware is the use of the <code>CALLBACK_FRAME</code>
macro: it defines your function argument variable names <i>a priori</i>, which
can be easy to overlook when you're trying to figure out the name of the
variables to use in your timer callback function.  Unfortunately, most
of the current timer callback functions in the core code ignore the callback
variables.  When used, <i>p1</i> will always be zero (with the current code),
<i>p2</i> will be the <i>timerno</i> of the timer, <i>p3</i> will be time
elapsed on the timer (which should be less than or equal to zero), and
<i>data</i> will be <code>NULL</code>.

<pre>
static int auth_init_child(void) {
  <font color=green>/* Start the login timer */</font>
  if (TimeoutLogin)
    add_timer(TimeoutLogin, TIMER_LOGIN, &auth_module, login_timer_cb);
   
  if (get_param_ptr(main_server->conf, "DisplayConnect", FALSE) != NULL)
    _do_user_counts();
   
  return 0;
}
</pre>

<p>
This use of <code>add_timer()</code> illustrate how one registers one's timer
callback function, and starts the timer running.  Once the child process has
forked and <code>mod_auth</code>'s child initialization function called, the
client has until the timer expires to successfully authenticate.

<p>
When adding a timer, watch out for these predefined timer number/IDs:
<pre>
  #define TIMER_LOGIN               1
  #define TIMER_IDLE                2
  #define TIMER_NOXFER              3
  #define TIMER_STALLED             4
</pre>
Note that there is no requirement that your timer number be a preprocessor
macro.  The author has successfully used randomly generated numbers as
unique timer identifiers, so that each timer could have custom actions and
values.

<p>
<b>How Timers Work</b><br>
The timer mechanism is based on <code>SIGALRM</code> and a single signal
handler for that signal.  How then can multiple timers all use one signal
handler?  A linked list of timers is maintained, and that list is checked 
every time <code>SIGARLM</code> is received.  For each timer, the amount
of time that has expired is calculated, and if the specifier timer length
has been reached, that timer's callback is invoked.

<p>
One caveat to keep in mind is that timers <b>do not</b> provide fine-grained
time resolution, and are not meant for precise work.  They do well for
approximate timing-based sorts of activities.

<p>
When <code>add_timer()</code> is called, a list of old, recyclable timers
is checked, to see if any are available.  If none are avaiable, a new timer
is allocated.  The timer is given the caller's parameters, then inserted
into the active timer list.
<p>
At present, the callback function is invoked thus, from src/timers.c:86:
<pre>
  t->callback(t->interval, t->timerno, t->interval - t->count, t->mod) == 0 {
</pre>
This shows what is actually passed as the arguments in the callback_t.
<p>
Be aware that the pending signal set for a process is reset when
<code>fork()</code> is called.  This is why modules should and do register
timers for the child process in their respective child initialization
functions.

<p>
<center><a href="../toc.html">Table of Contents</a></center><br>

<hr><br>

Author: <i>$Author$</i><br>
Last Updated: <i>$Date$</i><br>

<br><hr>

<font size=2><b><i>
&copy; Copyright 2000-2003 TJ Saunders<br>
 All Rights Reserved<br>
</i></b></font>

<hr><br>

</body>
</html>
