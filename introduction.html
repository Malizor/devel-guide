<!-- $Id$ -->
<!-- $Source$ -->

<html>
<head> 
<title>ProFTPD Developer's Guide: Introduction</title>
</head>

<body bgcolor=white>

<hr><br>
<center>
<img src="images/proftpd.png">
<br><br>
<h3><b>ProFTPD Developer's Guide: Introduction</b></h3>
<i><b>ProFTPD Version 1.2</b></i><br>
</center>
<hr><br>

<p>
<center><a href="toc.html">Table of Contents</a></center><br>

<hr>

<b>ProFTPD is an FTP server modeled around the Apache HTTP server, with
a similar configuration file syntax and modular structure.  In light of this
similarity, I have utilized (<i>ie</i> plagiarized) the
<a href="http://httpd.apache.org/docs/misc/API.html">Apache API</a>
documentation, as many of the concepts are the same.  Some of the words and
explanations below are not mine.</b><br>

<hr>

<p>
These are some notes on the ProFTPD API and the data structures you
have to deal with, <em>etc.</em>  They are not yet nearly complete, but
hopefully, they will help you get your bearings.  Keep in mind that
the API is still subject to change as we gain experience with it.
However, it will be easy to adapt modules to any changes that are made.

<hr width=70%>

<p>
<b>Handlers, Modules, and Commands</b><br>

ProFTPD breaks down command handling into a series of simple steps, similar to
the way the Apache API breaks down request handling.  These are:

<ul>
  <li>Preprocess the command
  <li>Process the command
  <li>Postprocess the command
  <li>Log the command
</ul>

These phases are handled by looking at each of a succession of
<em>modules</em>, looking to see if each of them has a handler for the
phase, and attempting invoking it if so.  The handler can typically do
one of three things:

<ul>
  <li><em>Handle</em> the command, and indicate to the processing engine
      that it should consider the command completed, and continue its
      processing.
  <li><em>Decline</em> to handle the command, and indicate to the processing
      engine that it should act as if the handler waas never called, and to
      continue its procesing.
  <li>Signal an <em>error</em>, by returning one of the FTP error codes.
       This terminates normal handling of the request; the command
       may be logged.
</ul>

<p>
Most phases are terminated by the first module that handles them.
The handlers themselves are functions of one argument (a
<a href="api/typedefs.html#cmd_rec"><code>cmd_rec</code></a> structure),
which returns a <code>MODRET</code> (a <a href="api/structs.html#modret_struc">
<code>modret_struc</code></a> <code>typdef</code>ed to <code>MODRET</code>).

<p>
At this point, we need to explain the structure of a module.  Our
candidate will be one of the simple ones, the &quot;case&quot; module -- this
will alter the case (<em>e.g.</em> lowercase or uppercase) of the letters in
the name of the file requested by a client for download, before the server
looks up that file.

<p>
Let's start with the command handlers.  In order to catch the names of the
requested files before the server retrieves them, the module declares
a command handler that is interested in handling any download commands
issued by a client.

<p>
This module also contains code to handle the <code>DowncaseFileNames</code>
and <code>UpcaseFileNames</code> configuration commands themselves.  To
handle these multiple configuration commands, modules have <em>command
tables</em> which declare their commands, and the corresponding configuration
directive handler.  The configuration directive handler performs such checks
as whether the configuration directive is in an appropriate context, whether
the arguments are correct, <em>etc</em>.

<p>
A final note on the declared types of the arguments of some of these
commands: a <code>pool</code> is a pointer to a <em>resource pool</em>
structure; these are used by the server to keep track of the memory
which has been allocated, files opened, <em>etc.</em>, either to service a
particular request, or to handle the process of configuration itself.
That way, when the request is over (or, for the configuration pool,
when the server is restarting), the memory can be freed, and the files
closed, <em>en masse</em>, without anyone having to write explicit code to
track them all down and dispose of them.

<p>
With no further ado, the module itself:

<pre>
  <font color=blue>/* Declaration of command handler
   */</font>
  MODRET fixup_filenames(cmd_rec *);

  <font color=blue>/* Declaration of configuration directive handlers
   */</font>
  MODRET set_lowercase_filenames(cmd_rec *);
  MODRET set_uppercase_filenames(cmd_rec *);

  <font color=blue>/* Define the "configuration handler" table, which links configuration file
   * directives with the appropriate handlers in this module
   */</font>
  static conftable case_conftab[] = {
    { "DowncaseFileNames",  set_downcase_filenames, NULL },
    { "UpcaseFilenames", set_upcase_filenames, NULL },
    { NULL }
  };

  <font color=blue>/* Define the "command handler" table, which links client-issued commands
   * with the interested handlers in this module
   */</font>
  static cmdtable case_cmdtab[] = {
    { PRE_CMD, C_RETR, G_NONE, fixup_filenames, TRUE, FALSE },
    { 0, NULL }
  };

  module case_module = {

    NULL,                   <font color=blue>/* pointer to the next module -- ALWAYS NULL */</font>
    NULL,                   <font color=blue>/* pointer to the previous module -- ALWAYS NULL */</font>
    0x20,                   <font color=blue>/* ProFTPD Module API version 2.0 */</font>
    "case",                 <font color=blue>/* the module's name */</font>
    case_conftab,           <font color=blue>/* configuration command handler table */</font>
    case_cmdtab,            <font color=blue>/* command handler table */</font>
    NULL,                   <font color=blue>/* authentication function table */</font>
    NULL,                   <font color=blue>/* initialization function */</font>
    NULL                    <font color=blue>/* "child" initialization function */</font>
  };
</pre>

<p>
<b>How Handlers Work</b><br>
The sole argument to handlers is a <code>cmd_rec</code> structure.
This structure describes a particular command which has been made to
the server, on behalf of a client.  Each connection by a client generates
multiple <code>cmd_rec</code> structures, starting with the USER command.

<p>
The <code>cmd_rec</code> contains pointers to a resource pool
which will be cleared when the server is finished handling the
command; to structures containing per-server information, and most
importantly, information on the command itself.

<p>
Also present are pointers to private data a handler has built in the course of
servicing the command (so modules' handlers for one phase can pass `notes' to
their handlers for other phases),  and to a <code>server_rec</code>,
which contains per (virtual) server configuration data.

<p>
<a href="api/structs.html#cmd_rec">Here</a> is a declaration of the
<code>cmd_rec</code> struct.

<p>
Most <code>cmd_rec</code> structures are built by when the processing
engine reads an FTP command from a client, and fills in the fields.  The
filled-in <code>cmd_rec</code> is then handed off to the command handlers
that have registered an interest in handling that particular FTP command.

<p>
<b>Command Responses</b><br>
As discussed above, each handler, when invoked to handle a particular
<code>cmd_rec</code>, has to return a <code>MODRET</code>,
usually one generated by some <a href="responses/macros.html">macros</a>, to
indicate what happened.  That can be one of:

<ul>
  <li><code>HANDLED</code> -- the command was handled successfully.  This may
      or may not terminate the phase.
  <li><code>DECLINED</code> -- no erroneous condition exists, but the module
      declines to handle the phase; the server tries to find another.
  <li><code>ERROR</code> -- an error has occurred while processing the
      command, which aborts its handling.
</ul>

<p>
There are two main ways to respond to a client command inside a command
handler.  The first way is incompatible with other handlers, and
should only be used if the handler is about to terminate the current
connection (and thus kill the connection, usually with end_login()).  This
first method must be used because in the event that a handler is about to
terminate a connection, the internal response lists will never be processed by
the processing engine.

<p>
The second, and preferred, method of transmitting numeric plus text message
responses to clients is via the internal response chain.  Using this
allows all handlers to add their own individual responses which will all
be sent <em>en masse</em> after the command successfully completes (or fails).

<p>
<a href="responses/index.html">Here</a> is more detailed information on
ProFTPD's response chain mechanisms.

<p>
<b>Authentication Handlers</b><br>
The processing of authentication commands is a little different from the
other FTP commands.

<p>
<i>
NOTE: Stuff that should be discussed here:

<ul>
  <li>authentication commands of USER, PASS (RFC2228 AUTH, ADAT)
  <li>authtab and specific authentication handlers (mod_unixpw and mod_lap
    examples)
  <li>relevant FTP error response codes
</ul>
</i>

<p>
<b>Logging Handlers</b><br>
The logging of commands occurs as part of the handling process, and can be
done at multiple points in the process.

<p>
<i>
Stuff that should be discussed here:

<ul>
  <li>LOG_CMD, LOG_CMD_ERR
  <li>mod_log, mod_xfer, mod_sample's log_cmd()
</ul>
</i>

<hr width=70%>

<p>
<b>Resource Allocation and Resource Pools</b><br>
One of the problems of writing and designing a server-pool server is
that of preventing leakage, that is, allocating resources (memory,
open files, <em>etc.</em>), without subsequently releasing them.  The resource
pool machinery is designed to make it easy to prevent this from
happening, by allowing resource to be allocated in such a way that
they are <em>automatically</em> released when the server is done with
them.

<p>
The way this works is as follows:  the memory which is allocated, file
opened, <em>etc.</em>, to deal with a particular command are tied to a
<em>resource pool</em> which is allocated for the command.  The pool
is a data structure which itself tracks the resources in question.

<p>
When the command has been processed, the pool is <em>cleared</em>.  At
that point, all the memory associated with it is released for reuse,
all files associated with it are closed, and any other clean-up
functions which are associated with the pool are run.  When this is
over, we can be confident that all the resource tied to the pool have
been released, and that none of them have leaked.

<p>
Server restarts, and allocation of memory and resources for per-server
configuration, are handled in a similar way.  There is a
<em>configuration pool</em>, which keeps track of resources which were
allocated while reading the server configuration files, and handling
the commands therein (for instance, the memory that was allocated for
per-server module configuration, log files and other files that were
opened, and so forth).  When the server restarts, and has to reread
the configuration files, the configuration pool is cleared, and so the
memory and file descriptors which were taken up by reading them the
last time are made available for reuse.

<p>
We begin here by describing how memory is allocated to pools, and then
discuss how other resources are tracked by the resource pool
machinery.

<p>
<b>Allocation of memory in pools</b><br>
Memory is allocated to pools by calling the function
<code>palloc()</code>, which takes two arguments, one being a pointer to a
resource pool structure, and the other being the amount of memory to allocate
(in <code>int</code>s).  Within handlers for handling commands, the most common
way of getting a resource pool structure is by looking at the <code>pool</code>
(or <code>tmp_pool</code>, if appropriate) slot of the relevant
<code>cmd_rec</code>; hence the repeated appearance of the following idiom in
module code:

<pre>
  MODRET my_handler(cmd_rec *cmd) {
      struct my_structure *foo;
      ...

      foo = (foo *) palloc (cmd-&gt;pool, sizeof(my_structure));
  }
</pre>

<p>
Note that <em>there is no <code>pfree()</code></em> -- <code>palloc()</code>ed
memory is freed only when the associated resource pool is cleared.  This means
that <code>palloc()</code> does not have to do as much accounting as
<code>malloc()</code>; all it does in the typical case is to round up the
size, bump a pointer, and do a range check.


<p>
<b>Allocating initialized memory</b><br>
There are functions which allocate initialized memory, and are
frequently useful.  The function <code>pcalloc()</code> has the same
interface as <code>palloc()</code>, but clears out the memory it
allocates before it returns it.  The function <code>pstrdup()</code>
takes a resource pool and a <code>char *</code> as arguments
(<code>pstrndup()</code> takes an additional <code>int</code>), and
allocates memory for a copy of the string the pointer points to,
returning a pointer to the copy.  Finally <code>pstrcat()</code> is a
varargs-style function, which takes a pointer to a resource pool, and
the additional arguments, of which the last one should be <code>NULL</code>.
It allocates enough memory to fit copies of each of the strings, as a unit;
for instance:

<pre>
     pstrcat(cmd-&gt;pool, "foo", "/", "bar", NULL);
</pre>

<p>
returns a pointer to 8 bytes worth of memory, initialized to
<code>"foo/bar"</code>.

<p>
For almost everything folks do, <code>cmd-&gt;pool</code> is the pool to use.
For memory needed just for the scope of the handler function,
<code>cmd-&gt;tmp_pool</code> is also useful.

<p>
<b>Tracking open files, etc.</b><br>
As indicated above, resource pools are also used to track other sorts
of resources besides memory.  The most common are open files.  The
routine which is typically used for this is <code>pfopen()</code>, which
takes a resource pool and two strings as arguments; the strings are
the same as the typical arguments to <code>fopen()</code>, <em>e.g.</em>:<br>

<pre>
     ...

     FILE *f = pfopen(cmd-&gt;pool, cmd-&gt;args, "r");

     if (f == NULL) { ... } else { ... }

     ...
</pre>

<p>
There is also a <code>popenf()</code> routine, which parallels the
lower-level <code>open()</code> system call.  Both of these routines
arrange for the file to be closed when the resource pool in question
is cleared.

<p>
Unlike the case for memory, there <em>are</em> functions to close
files allocated with <code>pfopen()</code>, and <code>popenf()</code>,
namely <code>pfclose()</code> and <code>pclosef()</code>.  (This is
because, on many systems, the number of files which a single process
can have open is quite limited).  It is important to use these
functions to close files allocated with <code>pfopen()</code> and
<code>popenf()</code>, since to do otherwise could cause fatal errors on
systems such as Linux, which react badly if the same
<code>FILE *</code> is closed more than once.

<p>
(Using the <code>close()</code> functions is not mandatory, since the
file will eventually be closed regardless, but you should consider it
in cases where your module is opening, or could open, a lot of files).

<p>
Pool cleanups live until <code>clear_pool()</code> is called:
<code>clear_pool(p)</code> recursively calls <code>destroy_pool()</code> on
all subpools of <i>p</i>; then calls all the cleanups for <i>p</i>; 
then releases all the memory for <i>p</i>. <code>destroy_pool(p)</code> calls
<code>clear_pool(p)</code> and then releases the pool structure itself,
<em>i.e.</em>, <code>clear_pool(p)</code> doesn't delete <i>p</i>, it just
frees up all the resources and you can start using it again immediately. 

<hr width=70%>

<p>
<b>Configuration Directives</b><br>
Given configuration directives, we need to be able to figure out what to
do with them.  In this case, it involves processing the actual
<code>DowncaseFileNames</code> and <code>UpcaseFileNames</code> directives.
To find directives, the processing engine looks in the module's
<code>configuration table</code>.  That table contains information on
what directives the module handles and the corresponding configuration
handler. Without further ado, let's look at the <code>DowncaseFileNames</code>
configuration handler, which looks like this (the <code>UpcaseFileNames</code>
directive looks basically the same, and won't be shown here):

<pre>
  MODRET set_lowercase_filenames(cmd_rec *cmd) {

    int bool = -1;
    config_rec *c = NULL;

    <font color=blue>/* make sure the directive was given one, and only one, argument
     */</font>
    CHECK_ARGS(cmd, 1);

    <font color=blue>/* check the context in which the directive was used, make sure that
     * it was one of the allowed contexts of "server config", &lt;Anonymous&gt;,
     * &lt;Limit&gt;, or &lt;VirtualHost&gt;.
     */</font>
    CHECK_CONF(cmd, CONF_ROOT|CONF_ANON|CONF_LIMIT|CONF_VIRTUAL);

    <font color=blue>/* get_boolean() couldn't find a valid Boolean value as an argument
     */</font>
    if ((bool = get_boolean(cmd, 1)) == -1)
      CONF_ERROR(cmd, "requires a boolean value");

    c = add_config_param("DowncaseFileNames", 1, (void *) bool);

    <font color=blue>/* merge this configuration directive "down", so that it affects any
     * contained contexts
     */</font>
    c->flags |= CF_MERGEDOWN;

    return HANDLED(cmd);
  }
</pre>

<p>
This is a fairly typical configuration handler.  As you can see, it takes
only one argument, a <code>cmd_rec</code> pointer.  That structure contains a
bunch of arguments which are frequently of use to some, but not all, commands,
including a resource pool (from which memory can be allocated, and to which
cleanups should be tied), and the (virtual) server being configured, from
which the module's per-server configuration data can be obtained if required.

<p>
It is also fairly typical in its checking of the configuration directive
arguments.  The number of arguments is checked with <code>CHECK_ARGS</code>,
which in this case requires that only one argument be used with the directive.
Next, the configuration context is checked with <code>CHECK_CONF</code>.
Finally, since this configuration directive needs only a <code>true</code> or
<code>false</code> argument, the given argument is parsed as a Boolean
value, and an error generated if this is not the case.

<p>
The <code>DowncaseFileNames</code> configuration directive will automatically
be stored in the configuration records for the containing server, either
&quot;main&quot; (for anything outside of <code>&lt;Anonymous&gt;</code>
and <code>&lt;VirtualHost&gt;</code> contexts), <code>&lt;Anonymous&gt;</code>,
or <code>&lt;VirtualHost&gt;</code>.  The <code>server_rec</code> for the
containing server of the configuration directive's <code>cmd_rec</code> is
pointed to by <code>cmd-&gt;server</code>.

<p>
The &quot;case&quot; module's configuration table has entries for these
directives, which look like this (as seen above):

<pre>
  static conftable case_conftab[] = {
    { "DowncaseFileNames",  set_downcase_filenames, NULL },
    { "UpcaseFilenames", set_upcase_filenames, NULL },
    { NULL }
  };
</pre>

The entries in these tables are:

<ul>
  <li>the name of the configuration directive
  <li>the function which handles it
  <li>a pointer which is set to the &quot;owning&quot; module when the
       module code is compiled; should always be set to <code>NULL</code>.
</ul>

<p>
Finally, having set this all up, we have to use it.  This is ultimately done
in the module's handlers, specifically for its filename handler, which looks
more or less like this:

<pre>
  MODRET fixup_filenames(cmd_rec *cmd) {

    unsigned int index;
    char *current_filename = NULL, *new_filename = NULL;
    config_rec *conf_downcase = NULL, *conf_upcase = NULL;

    <font color=blue>/* check the current configuration context for the configuration
     * directive boolean value, true or false.  If false, return now
     */</font>

    conf_downcase = find_config(CURRENT_CONF, CONF_PARAM, "DowncaseFileNames",
      FALSE);
    conf_upcase = find_config(CURRENT_CONF, CONF_PARAM, "UpcaseFileNames",
      FALSE);

    if (!conf_downcase && !conf_upcase)
      return DECLINED(cmd);

    <font color=blue>/* get an adjusted requested filename
     */</font>
    if (conf_downcase->argv[0] == TRUE)
      new_filename = adjust_filename(cmd->server->pool, cmd->arg, PR_CASE_DOWN);

    else if (conf_upcase->argv[0] == TRUE)
      new_filename = adjust_filename(cmd->server->pool, cmd->arg, PR_CASE_UP);

    <font color=blue>/* copy the new filename into the command record */</font>
    sstrcpy(cmd->arg, new_filename, strlen(new_filename));

    <font color=blue>/* done -- proceed with the download
     */</font>
    return DECLINED(cmd);
  }
</pre>

<p>
The registration of this as a command handler for downloads (the
FTP <code>RETR</code> command) is done in the cmdtable, shown earlier:
<pre>
  { PRE_CMD, C_RETR, G_NONE, fixup_filenames, TRUE, FALSE },
</pre>

<p>
The <code>DowncaseFileNames</code> or <code>UpcaseFileNames</code>
configuration directives are retrieved.  If neither applies to the file
requested for the RETR command, the handler <code>DECLINE</code>s, and
processing continues on to the next handler that is registered for this
command.  If one of the configuration directives <i>do</i> apply, the
&quot;fixup&quot; is done on the filename, then the handler exits with
a <code>DECLINE</code>, letting other handlers work on the <code>cmd_rec</code>,
which now has the adjusted filename.

<p>
The writing of the <code>adjust_filename()</code> function is left as an
exercise to you, the budding module developer.<br>

<br>

<hr>
<p>
One final important thing to note: this documentation is an attempt to
explain what the actual code is doing; the only true canonical source for
answers to any questions that might arise is the source code itself.
This documentation may, and most likely will, fall out of date, or not properly
reflect what the code is doing.  Therefore, the author of these documents
should not be held responsible if ProFTPD is not behaving exactly as described
here.  Instead, s/he should be held responsible for not describing things
exactly as ProFTPD is behaving.  As always, <em>caveat emptor</em>.<br>
<br>
<hr>

<p>
<center><a href="toc.html">Table of Contents</a></center><br>

<hr><br>

Author: <i>$Author$</i><br>
Last Updated: <i>$Date$</i><br>

<br><hr>

<font size=2><b><i>
&copy; Copyright 2000-2002 TJ Saunders<br>
 All Rights Reserved<br>
</i></b></font>

<hr><br>

</body>
</html>

